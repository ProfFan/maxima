@c Language: Brazilian Portuguese, Encoding: iso-8859-1
@c /Input.texi/1.56/Sat Jun  9 01:31:19 2007/-ko/
@menu
* Comentários::
* Arquivos::                       
* Funções e Variáveis Definidas para Entrada e Saída::  
@end menu

@node Comentários, Arquivos, Entrada e Saída, Entrada e Saída
@section Comentários

Um comentário na entrada do Maxima é qualquer texto entre @code{/*} e @code{*/}.

O analisador do Maxima trata um comentário como espação em branco para o propósito de
encontrar indicações no fluxo de entrada;
uma indicação sempre termina um comentário.
Uma entrada tal como @code{a/* foo */b} contém duas indicações, @code{a} e @code{b},
e não uma indicação simples @code{ab}.
Comentários são de outra ignorados pelo Maxima;
nem o conteúdo nem a localização dos comentários são armazenados pelo analisador de expressões de entrada.

Comentários podem ser aninhados de forma a terem um nível de estratificação arbitrario.
O delimitador @code{/*} e o delimitador @code{*/} formam pares.
A quantidade de @code{/*} deve ser a mesma quantidade de @code{*/}.

Exemplos:

@c ===beg===
@c /* aa is a variable of interest */  aa : 1234;
@c /* Value of bb depends on aa */  bb : aa^2;
@c /* User-defined infix operator */  infix ("b");
@c /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
@c /* Comments /* can be nested /* to arbitrary depth */ */ */  1 + xyz;
@c ===end===
@example
(%i1) /* aa is a variable of interest */  aa : 1234;
(%o1)                         1234
(%i2) /* Value of bb depends on aa */  bb : aa^2;
(%o2)                        1522756
(%i3) /* User-defined infix operator */  infix ("b");
(%o3)                           b
(%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
(%o4)                         a b c
(%i5) /* Comments /* can be nested /* to arbitrary depth */ */ */  1 + xyz;
(%o5)                        xyz + 1
@end example


@node Arquivos, Funções e Variáveis Definidas para Entrada e Saída, Comentários, Entrada e Saída
@section Arquivos
Um arquivo é simplesmente uma área sobre um dispositivo particular de armazenagem que contém dados ou texto.
Arquivos em disco são figurativamente agrupados dentro de "diretórios".
Um diretório é apenas uma lista de arquivos.
Comandos que lidam com arquivos são:
@code{save},
@code{load},
@code{loadfile},
@code{stringout},
@code{batch},
@code{demo},
@code{writefile},
@code{closefile},
e
@code{appendfile}.

@node Funções e Variáveis Definidas para Entrada e Saída,  , Arquivos, Entrada e Saída
@section Funções e Variáveis Definidas para Entrada e Saída de Dados

@anchor{file_output_append}
@defvr {Variável de opção} file_output_append
Valor padrão: @code{false}

@code{file_output_append} governa se funções de saída de arquivo
anexam ao final ou truncam seu arquivo de saída.
Quando @code{file_output_append} for @code{true},
tais funções anexam ao final de seu arquivo de saída.
De outra forma, o arquivo de saída é truncado.

@code{save}, @code{stringout}, e @code{with_stdout} respeitam @code{file_output_append}.
Outras funções que escrevem arquivos de saída não respeitam @code{file_output_append}.
Em particular, montagem de gráficos e traduções de funções sempre truncam seu arquivo de saída,
e @code{tex} e @code{appendfile} sempre anexam ao final.
@c WHAT ABOUT WRITEFILE ??

@end defvr

@anchor{appendfile}
@deffn {Função} appendfile (@var{nomearquivo})
Adiciona ao final de @var{nomearquivo} uma transcrição do console.
@code{appendfile} é o mesmo que @code{writefile}, 
exceto que o arquivo transcrito, se já existe, terá sempre alguma coisa adicionada ao seu final.

@code{closefile} fecha o arquivo transcrito que foi aberto anteriormente por @code{appendfile} ou por @code{writefile}.

@end deffn

@c batch CAN TAKE 'test AS AN OPTIONAL ARGUMENT IN WHICH CASE IT CALLS test-batch
@c (SAME AS run_testsuite) -- SHOULD DOCUMENT batch (file, 'test)
@c FIX BUG WHICH CAUSES batch (<file>, 'test) TO FAIL, THEN DOCUMENT IT HERE
@anchor{batch}
@deffn {Função} batch (@var{nomearquivo})
Lê expressões Maxima do arquivo @var{nomearquivo} e as avalia.
@code{batch} procura pelo arquivo @var{nomearquivo} na lista @code{file_search_maxima}.
Veja @code{file_search}.

@var{nomearquivo} compreende uma seq@"{u}ência de expressões Maxima,
cada uma terminada com @code{;} ou @code{$}.
A varável especial @code{%} e a função @code{%th}
referem-se a resultados prévios dentro do arquivo.
O arquivo pode incluir construções @code{:lisp}.
Espaços, tabulações, e o caracter de nova linha no arquivo serão ignorados.
um arquivo de entrada conveniente pode ser criado por um editor de texto ou pela função @code{stringout}.

@code{batch} lê cada expressão de entrada de @var{nomearquivo},
mostra a entrada para o console, 
calcula a correspondente expressão de saída,
e mostra a expressão de saída.
Rótulos de entrada são atribuídos para expressões de entrada
e rótulos de saída são atribuídos para expressões de saída.
@code{batch} avalia toda expressão de entrada no arquivo
a menos que exista um erro.
Se uma entrada de usuário for requisitada (por @code{asksign} ou por @code{askinteger}, por exemplo)
@code{batch} interrompe para coletar a entrada requisitada e então continua.

@c CTRL-C BREAKS batch IN CMUCL, BUT CLISP (ALTHO IT SHOWS "User break") KEEPS GOING !!!
@c DON'T KNOW ABOUT GCL !!!
O recurso de requisição de entrada ao usuário possibilita interromper @code{batch} pela digitação de @code{control-C} no console.
O efeito de @code{control-C} depende da subjacente implementação do Lisp.

@code{batch} tem muitos usos,
tais como fornecer um reservatório para trabalhar linhas de comando,
para fornecer demonstrações livres de erros,
ou para ajudar a organizar alguma coisa na solução de problemas complexos.

@code{batch} avalia seu argumento.
@c LACK OF A RETURN VALUE IS A BUG; THE INTENT IS TO RETURN THE FILE PATH, TO JUDGE BY THE SOURCE CODE
@code{batch} não possui valor de retorno.

Veja também @code{load}, @code{batchload}, e @code{demo}.

@end deffn

@c RECOMMEND CUTTING THIS ITEM, AS THE load SUBSUMES FUNCTIONALITY OF batchload
@anchor{batchload}
@deffn {Função} batchload (@var{nomearquivo})
Lê expressões Maxima de @var{nomearquivo} e as avalia,
sem mostrar a entrada ou expressões de saída
e sem atribuir rótulos para expressões de saída.
Saídas impressas (tais como produzidas por @code{print} ou @code{describe})
são mostradas, todavia.

A variável especial @code{%} e a função @code{%th}
referem-se a resultados anteriores do interpretador interativo,
não a resultados dentro do arquivo.
O arquivo não pode incluir construções @code{:lisp}.

@code{batchload} retorna o caminho de @var{nomearquivo}, como uma seq@"{u}ência de caracteres.
@code{batchload} avalia seu argumento.

Veja também @code{batch} e @code{load}.
@c batchload APPEARS TO HAVE THE SAME EFFECT AS load.  WHY NOT GET RID OF batchload ???

@end deffn

@anchor{closefile}
@deffn {Função} closefile ()
Fecha o arquivo transcrito aberto por @code{writefile} ou @code{appendfile}.

@end deffn

@anchor{concat}
@deffn {Função} concat (@var{arg_1}, @var{arg_2}, ...)
Concatena seus argumentos.
Os argumentos devem obrigatóriamente serem avaliados para atomos.
O valor de retorno ou é um símbolo se o primeiro argumento for um símbolo
ou é uma seq@"{u}ência de caracteres no formato do Maxima em caso contrário.

@code{concat} avalia seus argumentos.
O apóstrofo @code{'} evita avaliação.

@example
(%i1) y: 7$
(%i2) z: 88$
(%i3) concat (y, z/2);
(%o3)                          744
(%i4) concat ('y, z/2);
(%o4)                          y44
@end example

Um símbolo construído por @code{concat} pode
ser atribuído a um valor e aparecer em expressões.
O operador de atribuição @code{::} (duplo dois pontos) avalia seu lado esquerdo.

@example
(%i5) a: concat ('y, z/2);
(%o5)                          y44
(%i6) a:: 123;
(%o6)                          123
(%i7) y44;
(%o7)                          123
(%i8) b^a;
                               y44
(%o8)                         b
(%i9) %, numer;
                               123
(%o9)                         b
@end example

Note que embora @code{concat (1, 2)} seja visto como números no console, na realidade é uma seq@"{u}ência de caracteres no formato do Maxima.

@example
(%i10) concat (1, 2) + 3;
(%o10)                       12 + 3
@end example

@end deffn

@anchor{sconcat}
@deffn {Função} sconcat (@var{arg_1}, @var{arg_2}, ...)

Concatena seus argumentos em uma seq@"{u}ência de caracteres.
Ao contrário de @code{concat}, os argumentos arrumados @i{não} precisam ser atômicos.

O resultado é uma seq@"{u}ência de caracteres no format do Lisp.
@c THAT'S ODD; WHY NOT A MAXIMA STRING ??

@example
(%i1) sconcat ("xx[", 3, "]:", expand ((x+y)^3));
(%o1)               xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
@end example

@end deffn

@c AFTER REVIEWING src/displa.lisp, IT LOOKS LIKE THIS VARIABLE HAS NO EFFECT
@c CUT IT ON THE NEXT PASS
@c @defvar cursordisp
@c Default value: @code{true}
@c 
@c When @code{cursordisp} is @code{true}, expressões are drawn by
@c the displayer in logical sequence.  This only works with a console
@c which can do cursor movement.  If @code{false}, expressões are
@c printed line by line.
@c 
@c @code{cursordisp} is always @code{false} when a @code{writefile} is in
@c effect.
@c 
@c @end defvar

@c HMM, THIS NEXT ITEM IS DEFINED IN A SHARE FILE (itensor.lisp); 
@c DOES ITS DESCRIPTION WANT TO BE ELSEWHERE ???
@anchor{dispcon}
@deffn {Função} dispcon (@var{tensor_1}, @var{tensor_2}, ...)
@deffnx {Função} dispcon (all)
Mostra as propriedades de contração de
seus argumentos da forma que foram dadas para @code{defcon}.  @code{dispcon (all)} mostra todas as
propriedades de contração que foram definidas.

@end deffn

@anchor{error_size}
@defvr {Variável de opção} error_size
Valor padrão: 10

@code{error_size} modifica mensagens de erro conforme o tamanho das expressões que aparecem nelas.
Se o tamanho de uma expressão (como determinado pela função Lisp @code{ERROR-SIZE})
é maior que @code{error_size},
a expressão é substituída na mensagem por um símbolo,
e o o símbolo é atribuído à expressão.
Os símbolos são obtidos da lista @code{error_syms}.

De outra forma, a expressão é menor que @code{error_size},
e a expressão é mostrada na mensagem.

Veja também @code{error} e @code{error_syms}.

Exemplo:
@c OUTPUT GENERATED BY THE FOLLOWING
@c U: (C^D^E + B + A)/(cos(X-1) + 1)$
@c error_size: 20$
@c error ("Expressão exemplo é", U);
@c errexp1;
@c error_size: 30$
@c error ("Expressão exemplo é", U);

O tamanho de @code{U}, como determinado por @code{ERROR-SIZE}, é 24.

@example
(%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

(%i2) error_size: 20$

(%i3) error ("Expressão exemplo é", U);

Expressão exemplo é errexp1
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) errexp1;
                            E
                           D
                          C   + B + A
(%o4)                    --------------
                         cos(X - 1) + 1
(%i5) error_size: 30$

(%i6) error ("Expressão exemplo é", U);

                           E
                          D
                         C   + B + A
Expressão exemplo é --------------
                        cos(X - 1) + 1
 -- an error.  Quitting.  To debug this try debugmode(true);
@end example

@end defvr

@anchor{error_syms}
@defvr {Variável de opção} error_syms
Valor padrão: @code{[errexp1, errexp2, errexp3]}

Em mensagens de erro,
expressões mais largas que @code{error_size} são substituídas por símbolos, e os
símbolos são escolhidos para as expressões.  Os símbolos são obtidos da
lista @code{error_syms}.
A primeira expressão muito larga é substituída por @code{error_syms[1]},
a segunda por @code{error_syms[2]}, e assim por diante.

Se houverem mais expressões muito largas que há elementos em @code{error_syms},
símbolos são construídos automaticamente,
com o @var{n}-ésimo símbolo equivalente a @code{concat ('errexp, @var{n})}.

Veja também @code{error} e @code{error_size}.

@end defvr

@c NEEDS EXAMPLES
@anchor{filename_merge}
@deffn {Função} filename_merge (@var{path}, @var{nomearquivo})
Constroem um caminho modificado de @var{path} e @var{nomearquivo}.
Se o componente final de @var{path} é da forma @code{###.@var{algumacoisa}},
o componente é substituído com @code{@var{nomearquivo}.@var{algumacoisa}}.
De outra forma, o componente final é simplesmente substituído por @var{nomearquivo}.

@c SAY SOMETHING ABOUT ARG TYPE -- LISP STRINGS WORK BETTER THAN MAXIMA STRINGS
@c SAY SOMETHING ABOUT RETURN TYPE
@end deffn

@anchor{file_search}
@deffn {Função} file_search (@var{nomearquivo})
@deffnx {Função} file_search (@var{nomearquivo}, @var{listacaminho})

@code{file_search} procura pelo arquivo @var{nomearquivo} e retorna o caminho para o arquivo
(como uma seq@"{u}ência de caracteres) se ele for achado; de outra forma @code{file_search} retorna @code{false}.
@code{file_search (@var{nomearquivo})} procura nos diretórios padrões de busca,
que são especificados pelas variáveis @code{file_search_maxima}, @code{file_search_lisp}, e @code{file_search_demo}.

@code{file_search} primeiro verifica se o nome atual passado existe,
antes de tentar coincidir esse nome atual com o modelo ``coringa'' de busca do arquivo.
Veja @code{file_search_maxima} concernente a modelos de busca de arquivos.

O argumento @var{nomearquivo} pode ser um caminho e nome de arquivo,
ou apenas um nome de arquivo, ou, se um diretório de busca de arquivo inclui um modelo de busca de arquivo,
apenas a base do nome de arquivo (sem uma extensão).
Por exemplo,

@example
file_search ("/home/wfs/special/zeta.mac");
file_search ("zeta.mac");
file_search ("zeta");
@end example

todos encontram o mesmo arquivo, assumindo que o arquivo exista e @code{/home/wfs/special/###.mac}
está em @code{file_search_maxima}.

@code{file_search (@var{nomearquivo}, @var{listacaminho})} procura somente nesses diretórios
especificados por @var{listacaminho},
que é uma lista de seq@"{u}ências de caracteres.
O argumento @var{listacaminho} substitui os diretórios de busca padrão,
então se a lista do caminho é dada, @code{file_search} procura somente nesses especificados,
e não qualquer dos diretórios padrão de busca.
Mesmo se existe somente um diretório em @var{listacaminho}, esse deve ainda ser dado como uma lista de um único elemento.

O usuário pode modificar o diretório de busca padrão.  Veja @code{file_search_maxima}.

@code{file_search} é invocado por @code{load} com @code{file_search_maxima} e @code{file_search_lisp}
como diretórios de busca.

@end deffn

@anchor{file_search_maxima}
@anchor{file_search_lisp}
@anchor{file_search_demo}
@defvr {Variável de opção} file_search_maxima
@defvrx {Variável de opção} file_search_lisp
@defvrx {Variável de opção} file_search_demo
Essas variáveis especificam listas de diretórios a serem procurados
por @code{load}, @code{demo}, e algumas outras funções do Maxima.
O valor padrão dessas variáveis
nomeia vários diretórios na instalaçã padrão do Maxima.

O usuáro pode modificar essas variáveis,
quer substituindo os valores padrão ou colocando no final diretórios adicionais.
Por exemplo,

@example
file_search_maxima: ["/usr/local/foo/###.mac",
    "/usr/local/bar/###.mac"]$
@end example

substitui o valor padrão de @code{file_search_maxima},
enquanto

@example
file_search_maxima: append (file_search_maxima,
    ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$
@end example

adiciona no final da lista dois diretórios adicionais.
Isso pode ser conveniente para colocar assim uma expressão no arquivo @code{maxima-init.mac}
de forma que o caminho de busca de arquivo é atribuído automaticamente quando o Maxima inicia.

Multiplas extensões de arquivo e e multiplos caminhos podem ser especificados por
construções ``coringa'' especiais.
A seq@"{u}ência de caracteres @code{###} expande a busca para além do nome básico,
enquanto uma lista separada por vírgulas e entre chaves @code{@{foo,bar,baz@}} expande
em multiplas seq@"{u}ências de caracteres.
Por exemplo, supondo que o nome básico a ser procurado seja @code{neumann},

@example
"/home/@{wfs,gcj@}/###.@{lisp,mac@}"
@end example

expande em @code{/home/wfs/neumann.lisp}, @code{/home/gcj/neumann.lisp}, @code{/home/wfs/neumann.mac}, e @code{/home/gcj/neumann.mac}.

@end defvr

@anchor{file_type}
@deffn {Função} file_type (@var{nomearquivo})
Retorna uma suposta informação sobre o conteúdo de @var{nomearquivo},
baseada na extensão do arquivo.
@var{nomearquivo} não precisa referir-se a um arquivo atual;
nenhuma tentativa é feita para abrir o arquivo e inspecionar seu conteúdo.

O valor de retorno é um símbolo, qualquer um entre @code{object}, @code{lisp}, ou @code{maxima}.
Se a extensão começa com @code{m} ou @code{d}, @code{file_type} retorna @code{maxima}.
Se a extensão começa om @code{l}, @code{file_type} retorna @code{lisp}.
Se nenhum dos acima, @code{file_type} retorna @code{object}.

@end deffn

@anchor{load}
@deffn {Função} load (@var{nomearquivo})
Avalia expressões em @var{nomearquivo}, 
dessa forma conduzindo variáveis, funções, e outros objetos dentro do Maxima.
A associação de qualquer objeto existente é substituída pela associação recuperada de @var{nomearquivo}.  
Para achar o arquivo,
@code{load} chama @code{file_search} com @code{file_search_maxima} e @code{file_search_lisp}
como diretórios de busca.
Se @code{load} obtém sucesso, isso retorna o nome do arquivo.
De outra forma @code{load} imprime uma mensagem e erro.

@code{load} trabalha igualmente bem para códigos Lisp e códigos Maxima.
Arquivos criados por @code{save}, @code{translate_file}, e @code{compile_file}, que criam códigos Lisp,
e @code{stringout}, que criam códigos Maxima,
podem ser processadas por @code{load}.
@code{load} chama @code{loadfile} para carregar arquivos Lisp e @code{batchload} para carregar arquivos Maxima.

@code{load} não reconhece construções @code{:lisp} em arquivos do Maxima,
e quando processando @var{nomearquivo},
as variáveis globais @code{_}, @code{__}, @code{%}, e @code{%th} possuem as mesmas associações
que possuiam quando @code{load} foi chamada.

Veja também @code{loadfile}, @code{batch}, @code{batchload}, e @code{demo}.
@code{loadfile} processa arquivos Lisp;
@code{batch}, @code{batchload}, e @code{demo} processam arquivos Maxima.

Veja @code{file_search} para mais detalhes sobre o mecanismo de busca de arquivos.

@code{load} avalia seu argumento.

@end deffn

@c RECOMMEND CUTTING THIS ITEM, AS THE load SUBSUMES FUNCTIONALITY OF loadfile
@anchor{loadfile}
@deffn {Função} loadfile (@var{nomearquivo})
Avalia expressões Lisp em @var{nomearquivo}.
@code{loadfile} não invoca @code{file_search}, então @code{nomearquivo} deve obrigatóriamente incluir
a extensão do arquivo e tanto quanto o caminho como necessário para achar o arquivo.

@code{loadfile} pode processar arquivos criados por @code{save}, @code{translate_file}, e @code{compile_file}.
O usuário pode achar isso mais conveniente para usar @code{load} em lugar de @code{loadfile}.

@end deffn

@c loadprint DOESN'T EXACTLY WORK LIKE THIS, BUT IT HARDLY SEEMS WORTH FIXING
@c I GUESS THIS COULD BE UPDATED TO DESCRIBE THE WAY IT ACTUALLY WORKS
@anchor{loadprint}
@defvr {Variável de opção} loadprint
Valor padrão: @code{true}

@code{loadprint} diz se deve imprimir uma mensagem quando um arquivo é chamado.

@itemize @bullet
@item
Quando @code{loadprint} é @code{true}, sempre imprime uma mensagem.
@item
Quando @code{loadprint} é @code{'loadfile}, imprime uma mensagem somente se
um arquivo é chamado pela função @code{loadfile}.
@item
Quando @code{loadprint} é @code{'autoload},
imprime uma mensagem somente se um arquivo é automaticamente carregado.
Veja @code{setup_autoload}.
@item
Quando @code{loadprint} é @code{false}, nunca imprime uma mensagem.
@end itemize

@end defvr

@c STILL EXISTS, NEEDS CLARIFICATION !!!
@anchor{packagefile}
@defvr {Variável de opção} packagefile
Valor padrão: @code{false}

Projetistas de pacotes que usam @code{save}
ou @code{translate} para criar pacotes (arquivos) para outros
usarem podem querer escolher @code{packagefile: true} para prevenir qu informações
sejam acrescentadas à lista de informações do Maxima (e.g. @code{values},
@code{funções}) exceto onde necessário quando o arquivo é carregado.
Nesse caminho, o conteúdo do pacote não pegará no
caminho do usuário quando ele adicionar seus próprios dados.  Note que isso não
resolve o problema de possíveis conflitos de nome.  Também note que
o sinalizador simplesmente afeta o que é saída para o arquivo pacote.
Escolhendo o sinalizador para @code{true} é também útil para criar arquivos de
init do Maxima.

@end defvr

@c RECOMMEND CUTTING THIS ITEM AND CUTTING $tcl_output IN src/plot.lisp
@c THIS REALLY, REALLY SEEMS LIKE CRUFT:
@c $tcl_output IS NEVER CALLED WITHIN MAXIMA SOURCE,
@c AND THIS EXTREMELY NARROW, LIMITED FUNCTIONALITY ISN'T USEFUL TO USERS
@c AND IT'S BROKEN: INCORRECT OUTPUT FOR CLISP, DIES ON GCL
@anchor{tcl_output}
@deffn {Função} tcl_output (@var{list}, @var{i0}, @var{skip})
@deffnx {Função} tcl_output (@var{list}, @var{i0})
@deffnx {Função} tcl_output ([@var{list_1}, ..., @var{list_n}], @var{i})

Imprime os elementos de uma lista entre chaves @code{@{ @}},
conveniente como parte de um programa na linguagem Tcl/Tk.

@code{tcl_output (@var{list}, @var{i0}, @var{skip})}
imprime @var{list}, começando com o elemento @var{i0} e imprimindo elementos
@code{@var{i0} + @var{skip}}, @code{@var{i0} + 2 @var{skip}}, etc.

@code{tcl_output (@var{list}, @var{i0})}
é equivalente a @code{tcl_output (@var{list}, @var{i0}, 2)}.

@code{tcl_output ([@var{list_1}, ..., @var{list_n}], @var{i})}
imprime os @var{i}'ésimos elementos de @var{list_1}, ..., @var{list_n}.

Exemplos:
@c EXAMPLE INPUT
@c tcl_output ([1, 2, 3, 4, 5, 6], 1, 3)$
@c tcl_output ([1, 2, 3, 4, 5, 6], 2, 3)$
@c tcl_output ([3/7, 5/9, 11/13, 13/17], 1)$
@c tcl_output ([x1, y1, x2, y2, x3, y3], 2)$
@c tcl_output ([[1, 2, 3], [11, 22, 33]], 1)$

@c EXAMPLE OUTPUT: CLISP
@c OUTPUT IS OK FOR FIRST TWO, BROKEN FOR OTHERS
@c GCL OUTPUT: SAME FOR FIRST TWO
@c GCL FAILS ON OTHERS (IN EACH CASE COMPLAINING ELEMENTS ARE "not of type (OR RATIONAL LISP:FLOAT)"
@example
(%i1) tcl_output ([1, 2, 3, 4, 5, 6], 1, 3)$

 @{1.000000000     4.000000000     
 @}
(%i2) tcl_output ([1, 2, 3, 4, 5, 6], 2, 3)$

 @{2.000000000     5.000000000     
 @}
(%i3) tcl_output ([3/7, 5/9, 11/13, 13/17], 1)$

 @{((RAT SIMP) 3 7) ((RAT SIMP) 11 13) 
 @}
(%i4) tcl_output ([x1, y1, x2, y2, x3, y3], 2)$

 @{$Y1 $Y2 $Y3 
 @}
(%i5) tcl_output ([[1, 2, 3], [11, 22, 33]], 1)$

 @{SIMP 1.000000000     11.00000000     
 @}
@end example

@end deffn

@anchor{rmxchar}
@defvr {Variável de opção} rmxchar
Valor padrão: @code{]}

@code{rmxchar} é the caractere desenhado lado direito de uma matriz.

Veja também @code{lmxchar}.

@end defvr

@c NEEDS EXAMPLES
@anchor{save}
@deffn {Função} save (@var{nomearquivo}, @var{nome_1}, @var{nome_2}, @var{nome_3}, ...)
@deffnx {Função} save (@var{nomearquivo}, values, functions, labels, ...)
@deffnx {Função} save (@var{nomearquivo}, [@var{m}, @var{n}])
@deffnx {Função} save (@var{nomearquivo}, @var{nome_1}=@var{expr_1}, ...)
@deffnx {Função} save (@var{nomearquivo}, all)
@deffnx {Função} save (@var{nomearquivo}, @var{nome_1}=@var{expr_1}, @var{nome_2}=@var{expr_2}, ...)

Armazena os valores correntes de @var{nome_1}, @var{nome_2}, @var{nome_3}, ..., em @var{nomearquivo}.
Os argumentos são os nomes das variáveis, funções, ou outros objetos.
Se um nome não possui valore ou função associada a ele, esse nome sem nenhum valor ou função associado será ignorado.
@code{save} retorna @var{nomearquivo}.

@code{save} armazena dados na forma de expressões Lisp.
Os dados armazenados por @code{save} podem ser recuperados por @code{load (@var{nomearquivo})}.

O sinalizador global @code{file_output_append} governa
se @code{save} anexa ao final ou trunca o arquivo de saída.
Quando @code{file_output_append} for @code{true},
@code{save} anexa ao final doarquivo de saída.
De outra forma, @code{save} trunca o arquivo de saída.
Nesse caso, @code{save} cria o arquivo se ele não existir ainda.

A forma especial @code{save (@var{nomearquivo}, values, functions, labels, ...)}
armazena os ítens nomeados por @code{values}, @code{funções}, @code{labels}, etc.
Os nomes podem ser quaisquer especificados pela variável @code{infolists}.
@code{values} compreende todas as variáveis definidas pelo usuário.

A forma especial @code{save (@var{nomearquivo}, [@var{m}, @var{n}])} armazena os valores de
rótulos de entrada e saída de @var{m} até @var{n}.
Note que @var{m} e @var{n} devem obrigatóriamente ser inteiros literais.
Rótulos de entrada e saída podem também ser armazenados um a um, e.g., @code{save ("foo.1", %i42, %o42)}.
@code{save (@var{nomearquivo}, labels)} armazena todos os rótulos de entrada e saída.
Quando rótulos armazenados são recuperados, eles substituem rótulos existentes.

A forma especial @code{save (@var{nomearquivo}, @var{nome_1}=@var{expr_1}, @var{nome_2}=@var{expr_2}, ...)}
armazena os valores de @var{expr_1}, @var{expr_2}, ...,
com nomes @var{nome_1}, @var{nome_2}, ....
Isso é útil para aplicar essa forma para rótulos de entrada e saída, e.g., @code{save ("foo.1", aa=%o88)}.
O lado direito dessa igualdade nessa forma pode ser qualquer expressão, que é avaliada.
Essa forma não introduz os novos nomes no ambiente corrente do Maxima,
mas somente armazena-os em @var{nomearquivo}.

Essa forma especial e a forma geral de @code{save} podem ser misturados.
Por exemplo, @code{save (@var{nomearquivo}, aa, bb, cc=42, funções, [11, 17])}.

A forma especial @code{save (@var{nomearquivo}, all)} armazena o estado corrente do Maxima.
Isso inclui todas as variáveis definidas pelo usuário, funções, arrays, etc., bem como
alguns ítens definidos automaticamente.
Os ítes salvos incluem variáveis de sistema,
tais como @code{file_search_maxima} ou @code{showtime}, se a elas tiverem sido atribuídos novos valores pelo usuário;
veja @code{myoptions}.

@code{save} avalia @var{nomearquivo} e não avalia todos os outros argumentos.

@end deffn

@c NEEDS MORE WORK !!!
@anchor{savedef}
@defvr {Variável de opção} savedef
Valor padrão: @code{true}

Quando @code{savedef} é @code{true}, a vesão Maxima de uma
função de usuário é preservada quando a função é traduzida.
Isso permite que a definição seja mostrada por @code{dispfun} e autoriza a função a
ser editada.

Quando @code{savedef} é @code{false}, os nomes de funções traduzidas são
removidos da lista de @code{funções}.

@end defvr

@c THIS FUNCTION IS IN THE SHARE PACKAGE itensor.lisp
@c MOVE THIS DESCRIPTION TO Itensor.texi
@anchor{show}
@deffn {Função} show (@var{expr})
Mostra @code{expr} com os objetos indexados
tendo índices covariantes como subscritos, índices contravariantes como
sobrescritos.  Os índices derivativos são mostrados como subscritos,
separados dos índices covariantes por uma vírgula.

@end deffn

@anchor{showratvars}
@deffn {Função} showratvars (@var{expr})
Retorna uma lista de variáveis expressão racional canônica (CRE) na expressão @code{expr}.

Veja também @code{ratvars}.

@end deffn

@c NEEDS CLARIFICATION AND EXAMPLES
@anchor{string}
@deffn {Função} string (@var{expr})
Converte @code{expr} para a notação linear do Maxima
apenas como se tivesse sido digitada.

O valor de retorno de @code{string} é uma seq@"{u}ência de caracteres,
e dessa forma não pode ser usada em um cálculo.

@end deffn

@anchor{stringdisp}
@defvr {Variãvel de opção} stringdisp
Valor padrão: @code{false}

Quando @code{stringdisp} for @code{true},
seq@"{u}ências de caracteres serão mostradas contidas em aspas duplas.
De outra forma,
aspas não são mostradas.

@code{stringdisp} é sempre @code{true} quando mostrando na tela uma definição de função.

Exemplos:

@c ===beg===
@c stringdisp: false$
@c "This is an example string.";
@c foo () := print ("This is a string in a function definition.");
@c stringdisp: true$
@c "This is an example string.";
@c ===end===
@example
(%i1) stringdisp: false$
(%i2) "This is an example string.";
(%o2)              This is an example string.
(%i3) foo () := print ("This is a string in a function definition.");
(%o3) foo() := 
              print("This is a string in a function definition.")
(%i4) stringdisp: true$
(%i5) "This is an example string.";
(%o5)             "This is an example string."
@end example

@end defvr

@anchor{stringout}
@deffn {Função} stringout (@var{nomearquivo}, @var{expr_1}, @var{expr_2}, @var{expr_3}, ...)
@deffnx {Função} stringout (@var{nomearquivo}, [@var{m}, @var{n}])
@deffnx {Função} stringout (@var{nomearquivo}, input)
@deffnx {Função} stringout (@var{nomearquivo}, functions)
@deffnx {Função} stringout (@var{nomearquivo}, values)

@code{stringout} escreve expressões para um arquivo na mesma forma de
expressões que foram digitadas para entrada.  O arquivo pode então ser usado
como entrada para comandos @code{batch} ou @code{demo}, e isso pode ser editado para
qualquer propósito.  @code{stringout} pode ser executado enquanto @code{writefile} está em progresso.

O sinalizador global @code{file_output_append} governa
se @code{stringout} anexa ao final ou trunca o arquivo de saída.
Quando @code{file_output_append} for @code{true},
@code{stringout} anexa ao final do arquivo de sa@'da.
De outra forma, @code{stringout} trunca o arquivo de saída.
Nesse caso, @code{stringout} cria o arquivo de saída se ele não existir ainda.

A forma geral de @code{stringout} escreve os valores de um ou mais 
expressões para o arquivo de saída.  Note que se uma expressão é uma
variável, somente o valor da variável é escrito e não o nome
da variável.  Como um útil caso especial, as expressões podem ser
rótulos de entrada (@code{%i1}, @code{%i2}, @code{%i3}, ...) ou rótulos de saída (@code{%o1}, @code{%o2}, @code{%o3}, ...).

Se @code{grind} é @code{true}, @code{stringout} formata a saída usando o formato 
@code{grind}.  De outra forma o formato @code{string} é usado.  Veja @code{grind} e @code{string}.

A forma especial @code{stringout (@var{nomearquivo}, [@var{m}, @var{n}])} escreve os
valores dos rótulos de entrada de m até n, inclusive.  

A forma especial @code{stringout (@var{nomearquivo}, input)} escreve todos
os rótulos de entrada para o arquivo.

A forma especial @code{stringout (@var{nomearquivo}, functions)} escreve todas
as funções definidas pelo usuário (nomeadas pela lista global @code{functions}) para o arquivo.

A forma especial @code{stringout (@var{nomearquivo}, values)} escreve todas as
variáveis atribuídas pelo usuário (nomeadas pela lista global @code{values})
para o arquivo.  Cada variável é impressa como uma
declaração de atribuição, com o nome da variável seguida de dois pontos, e seu
valor.  Note que a forma geral de @code{stringout} não imprime 
variáveis como declarações de atribuição.

@end deffn

@anchor{tex}
@deffn {Função} tex (@var{expr})
@deffnx {Função} tex (@var{rótulo})
@deffnx {Função} tex (@var{expr}, @var{momearquivo})
@deffnx {Função} tex (@var{label}, @var{nomearquivo})

Imprime uma representação de uma expressão
adequada para o sistema TeX  de preparação de documento.
O resultado é um fragmento de um documento,
que pode ser copiado dentro de um documento maior
Esse fragmento não pode ser processado de forma direta e isolada.

@code{tex (@var{expr})} imprime uma representação TeX da @var{expr} no console.

@code{tex (@var{rótulo})} imprime uma representação TeX de uma expressão chamada @var{rótulo}
e atribui a essa um rótulo de equação (a ser mostrado à esquerda da expressão).
O rótulo de equação TeX é o mesmo que o rótulo da equação no Maxima.

@code{tex (@var{expr}, @var{nomearquivo})} anexa ao final uma representação TeX de @var{expr}
no arquivo @var{nomearquivo}.

@code{tex (@var{rótulo}, @var{nomearquivo})} anexa ao final uma representação TeX da
expressão chamada de @var{rótulo}, com um rótulo de equação, ao arquivo @var{nomearquivo}.

@code{tex} avalia seu primeiro argumento após testar esse argumento para ver se é um rótulo.
duplo apóstrofo @code{''} força a avaliação do argumento, desse modo frustrando o teste
e prevenindo o rótulo.

Veja também @code{texput}.

Exemplos:

@example
(%i1) integrate (1/(1+x^3), x);
                                    2 x - 1
                  2            atan(-------)
             log(x  - x + 1)        sqrt(3)    log(x + 1)
(%o1)      - --------------- + ------------- + ----------
                    6             sqrt(3)          3
(%i2) tex (%o1);
$$-@{@{\log \left(x^2-x+1\right)@}\over@{6@}@}+@{@{\arctan \left(@{@{2\,x-1
 @}\over@{\sqrt@{3@}@}@}\right)@}\over@{\sqrt@{3@}@}@}+@{@{\log \left(x+1\right)
 @}\over@{3@}@}\leqno@{\tt (\%o1)@}$$
(%o2)                          (\%o1)
(%i3) tex (integrate (sin(x), x));
$$-\cos x$$
(%o3)                           false
(%i4) tex (%o1, "foo.tex");
(%o4)                          (\%o1)
@end example

@end deffn

@anchor{texput}
@deffn {Função} texput (@var{a}, @var{s})
@deffnx {Função} texput (@var{a}, @var{s}, @var{operator_type})
@deffnx {Função} texput (@var{a}, [@var{s_1}, @var{s_2}], matchfix)
@deffnx {Função} texput (@var{a}, [@var{s_1}, @var{s_2}, @var{s_3}], matchfix)

Atribui a saída TeX para o átomo @var{a},
que pode ser um símbolo ou o nome de um operador.

@code{texput (@var{a}, @var{s})} faz com que a função @code{tex}
interpole a seq@"{u}ência de caracteres @var{s} dentro da saída TeX em lugar de @var{a}.

@code{texput (@var{a}, @var{s}, @var{operator_type})},
onde @var{operator_type} é @code{prefix}, @code{infix}, @code{postfix}, @code{nary}, ou @code{nofix},
faz com que a função @code{tex} interpole @var{s} dentro da saída TeX em lugar de @var{a},
e coloca o texto interpolado na posição apropriada.

@code{texput (@var{a}, [@var{s_1}, @var{s_2}], matchfix)}
faz com que a função @code{tex} interpole @var{s_1} e @var{s_2} dentro da saída TeX
sobre qualquer lado dos argumentos de @var{a}.
Os argumentos (se mais de um) são separados por vírgulas.

@code{texput (@var{a}, [@var{s_1}, @var{s_2}, @var{s_3}], matchfix)}
faz com que a função @code{tex} interpole @var{s_1} e @var{s_2} dentro da saída TeX
sobre qualquer lado dos argumentos de @var{a},
com @var{s_3} separando os argumentos.

Exemplos:

Atribui saída TeX a uma variável.
@c ===beg===
@c texput (me,"\\mu_e");
@c tex (me);
@c ===end===

@example
(%i1) texput (me,"\\mu_e");
(%o1)                         \mu_e
(%i2) tex (me);
$$\mu_e$$
(%o2)                         false
@end example

Atribui saída TeX a uma função comum (não a um operador).
@c ===beg===
@c texput (lcm, "\\mathrm{lcm}");
@c tex (lcm (a, b));
@c ===end===

@example
(%i1) texput (lcm, "\\mathrm@{lcm@}");
(%o1)                     \mathrm@{lcm@}
(%i2) tex (lcm (a, b));
$$\mathrm@{lcm@}\left(a , b\right)$$
(%o2)                         false
@end example

Atribui saída TeX a um operador prefixado.
@c ===beg===
@c prefix ("grad");
@c texput ("grad", " \\nabla ", prefix);
@c tex (grad f);
@c ===end===

@example
(%i1) prefix ("grad");
(%o1)                         grad
(%i2) texput ("grad", " \\nabla ", prefix);
(%o2)                        \nabla 
(%i3) tex (grad f);
$$ \nabla f$$
(%o3)                         false
@end example

Atribui saída TeX a um operador infixado.
@c ===beg===
@c infix ("~");
@c texput ("~", " \\times ", infix);
@c tex (a ~ b);
@c ===end===

@example
(%i1) infix ("~");
(%o1)                           ~
(%i2) texput ("~", " \\times ", infix);
(%o2)                        \times 
(%i3) tex (a ~ b);
$$a \times b$$
(%o3)                         false
@end example

Atribui saída TeX a um operadro pósfixado.
@c ===beg===
@c postfix ("##");
@c texput ("##", "!!", postfix);
@c tex (x ##);
@c ===end===

@example
(%i1) postfix ("##");
(%o1)                          ##
(%i2) texput ("##", "!!", postfix);
(%o2)                          !!
(%i3) tex (x ##);
$$x!!$$
(%o3)                         false
@end example

Atribui saída TeX a um operador n-ário.
@c ===beg===
@c nary ("@@");
@c texput ("@@", " \\circ ", nary);
@c tex (a @@ b @@ c @@ d);
@c ===end===

@example
(%i1) nary ("@@@@");
(%o1)                          @@@@
(%i2) texput ("@@@@", " \\circ ", nary);
(%o2)                         \circ 
(%i3) tex (a @@@@ b @@@@ c @@@@ d);
$$a \circ b \circ c \circ d$$
(%o3)                         false
@end example

Atribui saída TeX a um operador nofix.
@c ===beg===
@c nofix ("foo");
@c texput ("foo", "\\mathsc{foo}", nofix);
@c tex (foo);
@c ===end===

@example
(%i1) nofix ("foo");
(%o1)                          foo
(%i2) texput ("foo", "\\mathsc@{foo@}", nofix);
(%o2)                     \mathsc@{foo@}
(%i3) tex (foo);
$$\mathsc@{foo@}$$
(%o3)                         false
@end example

Atribui saída TeX a um operadro matchfix.
@c ===beg===
@c matchfix ("<<", ">>");
@c texput ("<<", [" \\langle ", " \\rangle "], matchfix);
@c tex (<<a>>);
@c tex (<<a, b>>);
@c texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"], matchfix);
@c tex (<<a>>);
@c tex (<<a, b>>);
@c ===end===

@example
(%i1) matchfix ("<<", ">>");
(%o1)                          <<
(%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
(%o2)                [ \langle ,  \rangle ]
(%i3) tex (<<a>>);
$$ \langle a \rangle $$
(%o3)                         false
(%i4) tex (<<a, b>>);
$$ \langle a , b \rangle $$
(%o4)                         false
(%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"], matchfix);
(%o5)           [ \langle ,  \rangle ,  \, | \,]
(%i6) tex (<<a>>);
$$ \langle a \rangle $$
(%o6)                         false
(%i7) tex (<<a, b>>);
$$ \langle a \, | \,b \rangle $$
(%o7)                         false
@end example

@end deffn

@c NEEDS CLARIFICATION
@anchor{system}
@deffn {Função} system (@var{comando})
Executa @var{comando} como um processo separado.
O comando é passado ao shell padrão para execução.
@code{system} não é suportado por todos os sistemas
operacionais, mas geralmente existe em ambientes Unix e Unix-like.

Supondo que @code{_hist.out}
é uma lista de freq@"{u}ência que você deseja imprimir como um gráfico em barras
usando @code{xgraph}.  

@example
(%i1) (with_stdout("_hist.out",
           for i:1 thru length(hist) do (
             print(i,hist[i]))),
       system("xgraph -bar -brw .7 -nl < _hist.out"));
@end example

Com o objetivo de fazer com que a impressão do gráfico seja concluída em segundo plano (retornando o controle para o Maxima)
e remover o arquivo temporário após isso ter sido concluído faça:

@example
system("(xgraph -bar -brw .7 -nl < _hist.out;  rm -f _hist.out)&")
@end example

@end deffn

@anchor{with_stdout}
@deffn {Função} with_stdout (@var{nomearquivo}, @var{expr_1}, @var{expr_2}, @var{expr_3}, ...)
Abre @var{nomearquivo} e então avalia @var{expr_1}, @var{expr_2}, @var{expr_3}, ....
Os valores dos argumentos não são armazenados em @var{nomearquivo},
mas qualquer saída impressa gerada pela avaliação dos argumentos
(de @code{print}, @code{display}, @code{disp}, ou @code{grind}, por exemplo)
vai para @var{nomearquivo} em lugar do console.

O sinalizador global @code{file_output_append} governa
se @code{with_stdout} anexa ao final ou trunca o arquivo de saída.
Quando @code{file_output_append} for @code{true},
@code{with_stdout} anexa ao final do arquivo de saída.
De outra forma, @code{with_stdout} trunca o arquivo de saída.
Nesse caso, @code{with_stdout} cria o arquivo se ele não existir ainda.

@code{with_stdout} retorna o valor do seu argumento final.

Veja também @code{writefile}.

@c THIS DOESN'T SEEM VERY IMPORTANT TO MENTION ...
@c Note the binding of display2d to be
@c false, otherwise the printing will have things like "- 3" instead
@c of "-3".
@c
@example
@c THIS EXAMPLE USES SOME UNIX-ISH CONSTRUCTS -- WILL IT WORK IN WINDOWS ???
@c ALSO IT'S SORT OF COMPLICATED AND THE SIMPLER SECOND EXAMPLE ILLUSTRATES with_stdout BETTER !!!
@c mygnuplot (f, var, range, number_ticks) :=
@c  block ([numer:true, display2d:false],
@c  with_stdout("tmp.out",
@c    dx: (range[2]-range[1])/number_ticks,
@c    for x: range[1] thru range[2] step dx
@c       do print (x, at (f, var=x))),
@c  system ("echo \"set data style lines; set title '", f,"' ;plot '/tmp/gnu'
@c ;pause 10 \" | gnuplot"))$
(%i1) with_stdout ("tmp.out", for i:5 thru 10 do print (i, "! yields", i!))$
(%i2) printfile ("tmp.out")$
5 ! yields 120 
6 ! yields 720 
7 ! yields 5040 
8 ! yields 40320 
9 ! yields 362880 
10 ! yields 3628800
@end example

@end deffn

@anchor{writefile}
@deffn {Função} writefile (@var{nomearquivo})
Começa escrevendo uma transcrição da sessão Maxima para @var{nomearquivo}.
Toda interação entre o usuário e Maxima é então gravada nesse arquivo,
@c FOLLOWING CLAIM PROBABLY NEEDS TO BE QUALIFIED
da mesma forma que aparece no console.

Como a transcrição é impressa no formato de saída do console,
isso não pode ser reaproveitado pelo Maxima.
Para fazer um arquivo contendo expressões que podem ser reaproveitadas,
veja @code{save} e @code{stringout}.
@code{save} armazena expressões no formato Lisp, enquanto @code{stringout} armazena expressões no formato Maxima.

O efeito de executar @code{writefile} quando @var{nomearquivo} ainda existe
depende da implementação Lisp subjacente;
o arquivo transcrito pode ser substituído, ou o arquivo pode receber um anexo.
@code{appendfile} sempre anexa para o arquivo transcrito.

Isso pode ser conveniente para executar @code{playback} após
@code{writefile} para salvar a visualização de interações prévias.
Como @code{playback} mostra somente as variáveis de entrada e saída (@code{%i1}, @code{%o1}, etc.),
qualquer saída gerada por uma declaração de impressão em uma função
(como oposição a um valor de retorno) não é mostrada por @code{playback}.

@code{closefile} fecha o arquivo transcrito aberto por @code{writefile} ou @code{appendfile}.

@end deffn

