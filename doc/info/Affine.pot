# This file contains all translatable strings from a .texi file.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL>, YEAR.
#
#, fuzzy
msgid ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-05-06 22:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL>\n"
"Language-Team: LANGUAGE <LL.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
msgstr ""

#: Affine.texi:6
msgid ""
"@c end concepts Affine\n"
"@menu\n"
"* Introduction to Affine::\n"
"* Functions and Variables for Affine::\n"
"@end menu\n"
msgstr ""

#: Affine.texi:9
msgid ""
"@node Introduction to Affine, Functions and Variables for Affine, Affine, Affine\n"
"@section Introduction to Affine\n"
msgstr ""

#: Affine.texi:11
msgid ""
"@code{affine} is a package to work with groups of polynomials.\n"
msgstr ""

#: Affine.texi:15
msgid ""
"@opencatbox\n"
"@category{Polynomials} @category{Groebner bases} @category{Share packages} @category{Package affine}\n"
"@closecatbox\n"
msgstr ""

#: Affine.texi:19
msgid ""
"@node Functions and Variables for Affine,  , Introduction to Affine, Affine\n"
"@section Functions and Variables for Affine\n"
msgstr ""

#: Affine.texi:26
msgid ""
"@anchor{fast_linsolve}\n"
"@deffn {Function} fast_linsolve ([@var{expr_1}, ..., @var{expr_m}], [@var{x_1}, ..., @var{x_n}])\n"
"Solves the simultaneous linear equations @var{expr_1}, ..., @var{expr_m}\n"
"for the variables @var{x_1}, ..., @var{x_n}.\n"
"Each @var{expr_i} may be an equation or a general expression;\n"
"if given as a general expression, it is treated as an equation of the form @code{@var{expr_i} = 0}.\n"
msgstr ""

#: Affine.texi:30
msgid ""
"The return value is a list of equations of the form\n"
"@code{[@var{x_1} = @var{a_1}, ..., @var{x_n} = @var{a_n}]}\n"
"where @var{a_1}, ..., @var{a_n} are all free of @var{x_1}, ..., @var{x_n}.\n"
msgstr ""

#: Affine.texi:33
msgid ""
"@code{fast_linsolve} is faster than @code{linsolve} for system of equations which\n"
"are sparse.\n"
msgstr ""

#: Affine.texi:35
msgid ""
"@code{load(affine)} loads this function.\n"
msgstr ""

#: Affine.texi:40
msgid ""
"@opencatbox\n"
"@category{Package affine}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Affine.texi:46
msgid ""
"@anchor{grobner_basis}\n"
"@deffn {Function} grobner_basis ([@var{expr_1}, ..., @var{expr_m}])\n"
"Returns a Groebner basis for the equations @var{expr_1}, ..., @var{expr_m}.\n"
"The function @code{polysimp} can then\n"
"be used to simplify other functions relative to the equations.\n"
msgstr ""

#: Affine.texi:49
msgid ""
"@example\n"
"grobner_basis ([3*x^2+1, y*x])$\n"
msgstr ""

#: Affine.texi:52
msgid ""
"polysimp (y^2*x + x^3*9 + 2) ==> -3*x + 2\n"
"@end example\n"
msgstr ""

#: Affine.texi:57
msgid ""
"@code{polysimp(f)} yields 0 if and only if @var{f} is in the ideal generated by\n"
"@var{expr_1}, ..., @var{expr_m}, that is,\n"
"if and only if @var{f} is a polynomial combination of the elements of\n"
"@var{expr_1}, ..., @var{expr_m}.\n"
msgstr ""

#: Affine.texi:59
msgid ""
"@code{load(affine)} loads this function.\n"
msgstr ""

#: Affine.texi:64
msgid ""
"@opencatbox\n"
"@category{Package affine}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Affine.texi:70
msgid ""
"@c NEEDS CLARIFICATION IN A SERIOUS WAY\n"
"@anchor{set_up_dot_simplifications}\n"
"@deffn {Function} set_up_dot_simplifications @\n"
"@fname{set_up_dot_simplifications} (@var{eqns}, @var{check_through_degree}) @\n"
"@fname{set_up_dot_simplifications} (@var{eqns})\n"
msgstr ""

#: Affine.texi:75
msgid ""
"The @var{eqns} are polynomial equations in non commutative variables.\n"
"The value of @code{current_variables} is the\n"
"list of variables used for computing degrees.  The equations must be\n"
"homogeneous, in order for the procedure to terminate.\n"
msgstr ""

#: Affine.texi:82
msgid ""
"If you have checked overlapping simplifications in @code{dot_simplifications}\n"
"above the degree of @var{f}, then the following is true:\n"
"@code{dotsimp (@var{f})} yields 0 if and only if @var{f} is in the\n"
"ideal generated by the equations, i.e.,\n"
"if and only if @var{f} is a polynomial combination\n"
"of the elements of the equations.\n"
msgstr ""

#: Affine.texi:85
msgid ""
"The degree is that returned by @code{nc_degree}.   This in turn is influenced by\n"
"the weights of individual variables.\n"
msgstr ""

#: Affine.texi:87
msgid ""
"@code{load(affine)} loads this function.\n"
msgstr ""

#: Affine.texi:92
msgid ""
"@opencatbox\n"
"@category{Package affine}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Affine.texi:97
msgid ""
"@anchor{declare_weights}\n"
"@deffn {Function} declare_weights (@var{x_1}, @var{w_1}, ..., @var{x_n}, @var{w_n})\n"
"Assigns weights @var{w_1}, ..., @var{w_n} to @var{x_1}, ..., @var{x_n}, respectively.\n"
"These are the weights used in computing @code{nc_degree}.\n"
msgstr ""

#: Affine.texi:99
msgid ""
"@code{load(affine)} loads this function.\n"
msgstr ""

#: Affine.texi:104
msgid ""
"@opencatbox\n"
"@category{Package affine}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Affine.texi:108
msgid ""
"@anchor{nc_degree}\n"
"@deffn {Function} nc_degree (@var{p})\n"
"Returns the degree of a noncommutative polynomial @var{p}.  See @code{declare_weights}.\n"
msgstr ""

#: Affine.texi:110
msgid ""
"@code{load(affine)} loads this function.\n"
msgstr ""

#: Affine.texi:115
msgid ""
"@opencatbox\n"
"@category{Package affine}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Affine.texi:121
msgid ""
"@c NEEDS CLARIFICATION -- TO WHICH EQUATIONS DOES THIS DESCRIPTION REFER ??\n"
"@anchor{dotsimp}\n"
"@deffn {Function} dotsimp (@var{f})\n"
"Returns 0 if and only if @var{f} is in the ideal generated by the equations, i.e.,\n"
"if and only if @var{f} is a polynomial combination of the elements of the equations.\n"
msgstr ""

#: Affine.texi:123
msgid ""
"@code{load(affine)} loads this function.\n"
msgstr ""

#: Affine.texi:128
msgid ""
"@opencatbox\n"
"@category{Package affine}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Affine.texi:133
msgid ""
"@anchor{fast_central_elements}\n"
"@deffn {Function} fast_central_elements ([@var{x_1}, ..., @var{x_n}], @var{n})\n"
"If @code{set_up_dot_simplifications} has been previously done, finds the central polynomials\n"
"in the variables @var{x_1}, ..., @var{x_n} in the given degree, @var{n}.\n"
msgstr ""

#: Affine.texi:140
msgid ""
"For example:\n"
"@example\n"
"set_up_dot_simplifications ([y.x + x.y], 3);\n"
"fast_central_elements ([x, y], 2);\n"
"[y.y, x.x];\n"
"@end example\n"
msgstr ""

#: Affine.texi:142
msgid ""
"@code{load(affine)} loads this function.\n"
msgstr ""

#: Affine.texi:147
msgid ""
"@opencatbox\n"
"@category{Package affine}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Affine.texi:159
msgid ""
"@c THIS IS NOT AT ALL CLEAR\n"
"@anchor{check_overlaps}\n"
"@deffn {Function} check_overlaps (@var{n}, @var{add_to_simps})\n"
"Checks the overlaps thru degree @var{n},\n"
"making sure that you have sufficient simplification rules in each\n"
"degree, for @code{dotsimp} to work correctly.  This process can be speeded\n"
"up if you know before hand what the dimension of the space of monomials is.\n"
"If it is of finite global dimension, then @code{hilbert} should be used.  If you\n"
"don't know the monomial dimensions, do not specify a @code{rank_function}.\n"
"An optional third argument @code{reset}, @code{false} says don't bother to query\n"
"about resetting things.\n"
msgstr ""

#: Affine.texi:161
msgid ""
"@code{load(affine)} loads this function.\n"
msgstr ""

#: Affine.texi:166
msgid ""
"@opencatbox\n"
"@category{Package affine}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Affine.texi:172
msgid ""
"@anchor{mono}\n"
"@deffn {Function} mono ([@var{x_1}, ..., @var{x_n}], @var{n})\n"
"Returns the list of independent\n"
"monomials relative to the current dot simplifications of degree @var{n}\n"
"in the variables @var{x_1}, ..., @var{x_n}.\n"
msgstr ""

#: Affine.texi:174
msgid ""
"@code{load(affine)} loads this function.\n"
msgstr ""

#: Affine.texi:179
msgid ""
"@opencatbox\n"
"@category{Package affine}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Affine.texi:183
msgid ""
"@anchor{monomial_dimensions}\n"
"@deffn {Function} monomial_dimensions (@var{n})\n"
"Compute the Hilbert series through degree @var{n} for the current algebra.\n"
msgstr ""

#: Affine.texi:185
msgid ""
"@code{load(affine)} loads this function.\n"
msgstr ""

#: Affine.texi:190
msgid ""
"@opencatbox\n"
"@category{Package affine}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Affine.texi:193
msgid ""
"@anchor{extract_linear_equations}\n"
"@deffn {Function} extract_linear_equations ([@var{p_1}, ..., @var{p_n}], [@var{m_1}, ..., @var{m_n}])\n"
msgstr ""

#: Affine.texi:198
msgid ""
"Makes a list of the coefficients of the noncommutative polynomials @var{p_1}, ..., @var{p_n}\n"
"of the noncommutative monomials @var{m_1}, ..., @var{m_n}.\n"
"The coefficients should be scalars.   Use @code{list_nc_monomials} to build the list of\n"
"monomials.\n"
msgstr ""

#: Affine.texi:200
msgid ""
"@code{load(affine)} loads this function.\n"
msgstr ""

#: Affine.texi:205
msgid ""
"@opencatbox\n"
"@category{Package affine}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Affine.texi:210
msgid ""
"@anchor{list_nc_monomials}\n"
"@deffn {Function} list_nc_monomials @\n"
"@fname{list_nc_monomials} ([@var{p_1}, ..., @var{p_n}]) @\n"
"@fname{list_nc_monomials} (@var{p})\n"
msgstr ""

#: Affine.texi:213
msgid ""
"Returns a list of the non commutative monomials occurring in a polynomial @var{p}\n"
"or a list of polynomials @var{p_1}, ..., @var{p_n}.\n"
msgstr ""

#: Affine.texi:215
msgid ""
"@code{load(affine)} loads this function.\n"
msgstr ""

#: Affine.texi:220
msgid ""
"@opencatbox\n"
"@category{Package affine}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Affine.texi:242
msgid ""
"@c THIS FUNCTION DOESN'T SEEM TO BE APPROPRIATE IN USER-LEVEL DOCUMENTATION\n"
"@c PRESERVE THIS DESCRIPTION PENDING FURTHER DECISION\n"
"@c @defun pcoeff (poly monom [variables-to-exclude-from-cof (list-variables monom)])\n"
"@c\n"
"@c This function is called from Lisp level, and uses internal poly format.\n"
"@c @example\n"
"@c\n"
"@c CL-MAXIMA>>(setq me (st-rat #$x^2*u+y+1$))\n"
"@c (#:Y 1 1 0 (#:X 2 (#:U 1 1) 0 1))\n"
"@c\n"
"@c CL-MAXIMA>>(pcoeff me (st-rat #$x^2$))\n"
"@c (#:U 1 1)\n"
"@c @end example\n"
"@c @noindent\n"
"@c\n"
"@c Rule: if a variable appears in monom it must be to the exact power,\n"
"@c and if it is in variables to exclude it may not appear unless it was\n"
"@c in monom to the exact power.  (pcoeff pol 1 ..) will exclude variables\n"
"@c like substituting them to be zero.\n"
"@c\n"
"@c @end defun\n"
msgstr ""

#: Affine.texi:258
msgid ""
"@c THIS FUNCTION DOESN'T SEEM TO BE APPROPRIATE IN USER-LEVEL DOCUMENTATION\n"
"@c PRESERVE THIS DESCRIPTION PENDING FURTHER DECISION\n"
"@c @defun new-disrep (poly)\n"
"@c\n"
"@c From Lisp this returns the general Maxima format for an arg which is\n"
"@c in st-rat form:\n"
"@c\n"
"@c @example\n"
"@c (displa(new-disrep (setq me (st-rat #$x^2*u+y+1$))))\n"
"@c\n"
"@c        2\n"
"@c y + u x  + 1\n"
"@c @end example\n"
"@c\n"
"@c @end defun\n"
msgstr ""

#: Affine.texi:262
msgid ""
"@anchor{all_dotsimp_denoms}\n"
"@defvr {Option variable} all_dotsimp_denoms\n"
"Default value: @code{false}\n"
msgstr ""

#: Affine.texi:267
msgid ""
"When @code{all_dotsimp_denoms} is a list,\n"
"the denominators encountered by @code{dotsimp} are appended to the list.\n"
"@code{all_dotsimp_denoms} may be initialized to an empty list @code{[]}\n"
"before calling @code{dotsimp}.\n"
msgstr ""

#: Affine.texi:269
msgid ""
"By default, denominators are not collected by @code{dotsimp}.\n"
msgstr ""

#: Affine.texi:273
msgid ""
"@opencatbox\n"
"@category{Package affine}\n"
"@closecatbox\n"
msgstr ""

#: Affine.texi:275
msgid ""
"@end defvr\n"
msgstr ""

