# SOME DESCRIPTIVE TITLE.">
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-05-06 22:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF8\n"
"Content-Transfer-Encoding: 8bit\n"
 
# Atensor.texi
msgid ""
"@menu\n"
"* Introduction to atensor::\n"
"* Functions and Variables for atensor::\n"
"@end menu\n"
msgstr ""

# Atensor.texi
msgid ""
"@node Introduction to atensor, Functions and Variables for atensor, atensor, atensor\n"
"@section Introduction to atensor\n"
msgstr ""

# Atensor.texi
msgid ""
"@code{atensor} is an algebraic tensor manipulation package. To use @code{atensor},\n"
"type @code{load(atensor)}, followed by a call to the @code{init_atensor}\n"
"function.\n"
msgstr ""

# Atensor.texi
msgid ""
"The essence of @code{atensor} is a set of simplification rules for the\n"
"noncommutative (dot) product operator (\"@code{.}\"). @code{atensor} recognizes\n"
"several algebra types; the corresponding simplification rules are put\n"
"into effect when the @code{init_atensor} function is called.\n"
msgstr ""

# Atensor.texi
msgid ""
"The capabilities of @code{atensor} can be demonstrated by defining the\n"
"algebra of quaternions as a Clifford-algebra Cl(0,2) with two basis\n"
"vectors. The three quaternionic imaginary units are then the two\n"
"basis vectors and their product, i.e.:\n"
msgstr ""

# Atensor.texi
msgid ""
"@example\n"
"    i = v     j = v     k = v  . v\n"
"         1         2         1    2\n"
"@end example\n"
msgstr ""

# Atensor.texi
msgid ""
"Although the @code{atensor} package has a built-in definition for the\n"
"quaternion algebra, it is not used in this example, in which we\n"
"endeavour to build the quaternion multiplication table as a matrix:\n"
msgstr ""

# Atensor.texi
msgid ""
"@example\n"
"(%i1) load(atensor);\n"
"(%o1)       /share/tensor/atensor.mac\n"
"(%i2) init_atensor(clifford,0,0,2);\n"
"(%o2)                                done\n"
"(%i3) atensimp(v[1].v[1]);\n"
"(%o3)                                 - 1\n"
"(%i4) atensimp((v[1].v[2]).(v[1].v[2]));\n"
"(%o4)                                 - 1\n"
"(%i5) q:zeromatrix(4,4);\n"
"                                [ 0  0  0  0 ]\n"
"                                [            ]\n"
"                                [ 0  0  0  0 ]\n"
"(%o5)                           [            ]\n"
"                                [ 0  0  0  0 ]\n"
"                                [            ]\n"
"                                [ 0  0  0  0 ]\n"
"(%i6) q[1,1]:1;\n"
"(%o6)                                  1\n"
"(%i7) for i thru adim do q[1,i+1]:q[i+1,1]:v[i];\n"
"(%o7)                                done\n"
"(%i8) q[1,4]:q[4,1]:v[1].v[2];\n"
"(%o8)                               v  . v\n"
"                                     1    2\n"
"(%i9) for i from 2 thru 4 do for j from 2 thru 4 do\n"
"      q[i,j]:atensimp(q[i,1].q[1,j]);\n"
"(%o9)                                done\n"
"(%i10) q;\n"
"@group\n"
"                   [    1        v         v      v  . v  ]\n"
"                   [              1         2      1    2 ]\n"
"                   [                                      ]\n"
"                   [   v         - 1     v  . v    - v    ]\n"
"                   [    1                 1    2      2   ]\n"
"(%o10)             [                                      ]\n"
"                   [   v      - v  . v     - 1      v     ]\n"
"                   [    2        1    2              1    ]\n"
"                   [                                      ]\n"
"                   [ v  . v      v        - v       - 1   ]\n"
"                   [  1    2      2          1            ]\n"
"@end group\n"
"@end example\n"
msgstr ""

# Atensor.texi
msgid ""
"@code{atensor} recognizes as base vectors indexed symbols, where the symbol\n"
"is that stored in @code{asymbol} and the index runs between 1 and @code{adim}.\n"
"For indexed symbols, and indexed symbols only, the bilinear forms\n"
"@code{sf}, @code{af}, and @code{av} are evaluated. The evaluation\n"
"substitutes the value of @code{aform[i,j]} in place of @code{fun(v[i],v[j])}\n"
"where @code{v} represents the value of @code{asymbol} and @code{fun} is\n"
"either @code{af} or @code{sf}; or, it substitutes @code{v[aform[i,j]]}\n"
"in place of @code{av(v[i],v[j])}.\n"
msgstr ""

# Atensor.texi
msgid ""
"Needless to say, the functions @code{sf}, @code{af} and @code{av}\n"
"can be redefined.\n"
msgstr ""

# Atensor.texi
msgid ""
"When the @code{atensor} package is loaded, the following flags are set:\n"
msgstr ""

# Atensor.texi
msgid ""
"@example\n"
"dotscrules:true;\n"
"dotdistrib:true;\n"
"dotexptsimp:false;\n"
"@end example\n"
msgstr ""

# Atensor.texi
msgid ""
"If you wish to experiment with a nonassociative algebra, you may also\n"
"consider setting @code{dotassoc} to @code{false}. In this case, however,\n"
"@code{atensimp} will not always be able to obtain the desired\n"
"simplifications.\n"
msgstr ""

# Atensor.texi
msgid ""
"@opencatbox\n"
"@category{Tensors} @category{Share packages} @category{Package atensor}\n"
"@closecatbox\n"
msgstr ""

# Atensor.texi
msgid ""
"@c end concepts atensor\n"
"@node Functions and Variables for atensor,  , Introduction to atensor, atensor\n"
msgstr ""

# Atensor.texi
msgid ""
"@section Functions and Variables for atensor\n"
msgstr ""

# Atensor.texi
msgid ""
"@anchor{init_atensor}\n"
"@deffn {Function} init_atensor @\n"
"@fname{init_atensor} (@var{alg_type}, @var{opt_dims}) @\n"
"@fname{init_atensor} (@var{alg_type})\n"
msgstr ""

# Atensor.texi
msgid ""
"Initializes the @code{atensor} package with the specified algebra type. @var{alg_type}\n"
"can be one of the following:\n"
msgstr ""

# Atensor.texi
msgid ""
"@code{universal}: The universal algebra has no commutation rules.\n"
msgstr ""

# Atensor.texi
msgid ""
"@code{grassmann}: The Grassman algebra is defined by the commutation\n"
"relation @code{u.v+v.u=0}.\n"
msgstr ""

# Atensor.texi
msgid ""
"@code{clifford}: The Clifford algebra is defined by the commutation\n"
"relation @code{u.v+v.u=-2*sf(u,v)} where @code{sf} is a symmetric\n"
"scalar-valued function. For this algebra, @var{opt_dims} can be up\n"
"to three nonnegative integers, representing the number of positive,\n"
"degenerate, and negative dimensions of the algebra, respectively. If\n"
"any @var{opt_dims} values are supplied, @code{atensor} will configure the\n"
"values of @code{adim} and @code{aform} appropriately. Otherwise,\n"
"@code{adim} will default to 0 and @code{aform} will not be defined.\n"
msgstr ""

# Atensor.texi
msgid ""
"@code{symmetric}: The symmetric algebra is defined by the commutation\n"
"relation @code{u.v-v.u=0}.\n"
msgstr ""

# Atensor.texi
msgid ""
"@code{symplectic}: The symplectic algebra is defined by the commutation\n"
"relation @code{u.v-v.u=2*af(u,v)} where @code{af} is an antisymmetric\n"
"scalar-valued function. For the symplectic algebra, @var{opt_dims} can\n"
"be up to two nonnegative integers, representing the nondegenerate and\n"
"degenerate dimensions, respectively. If any @var{opt_dims} values are\n"
"supplied, @code{atensor} will configure the values of @code{adim} and @code{aform}\n"
"appropriately. Otherwise, @code{adim} will default to 0 and @code{aform}\n"
"will not be defined.\n"
msgstr ""

# Atensor.texi
msgid ""
"@code{lie_envelop}: The algebra of the Lie envelope is defined by the\n"
"commutation relation @code{u.v-v.u=2*av(u,v)} where @code{av} is\n"
"an antisymmetric function.\n"
msgstr ""

# Atensor.texi
msgid ""
"The @code{init_atensor} function also recognizes several predefined\n"
"algebra types:\n"
msgstr ""

# Atensor.texi
msgid ""
"@code{complex} implements the algebra of complex numbers as the\n"
"Clifford algebra Cl(0,1). The call @code{init_atensor(complex)} is\n"
"equivalent to @code{init_atensor(clifford,0,0,1)}.\n"
msgstr ""

# Atensor.texi
msgid ""
"@code{quaternion} implements the algebra of quaternions. The call\n"
"@code{init_atensor (quaternion)} is equivalent to\n"
"@code{init_atensor (clifford,0,0,2)}.\n"
msgstr ""

# Atensor.texi
msgid ""
"@code{pauli} implements the algebra of Pauli-spinors as the Clifford-algebra\n"
"Cl(3,0). A call to @code{init_atensor(pauli)} is equivalent to\n"
"@code{init_atensor(clifford,3)}.\n"
msgstr ""

# Atensor.texi
msgid ""
"@code{dirac} implements the algebra of Dirac-spinors as the Clifford-algebra\n"
"Cl(3,1). A call to @code{init_atensor(dirac)} is equivalent to\n"
"@code{init_atensor(clifford,3,0,1)}.\n"
msgstr ""

# Atensor.texi
msgid ""
"@opencatbox\n"
"@category{Package atensor}\n"
"@closecatbox\n"
"@end deffn\n"
"@anchor{atensimp}\n"
"@deffn {Function} atensimp (@var{expr})\n"
msgstr ""

# Atensor.texi
msgid ""
"Simplifies an algebraic tensor expression @var{expr} according to the rules\n"
"configured by a call to @code{init_atensor}. Simplification includes\n"
"recursive application of commutation relations and resolving calls\n"
"to @code{sf}, @code{af}, and @code{av} where applicable. A\n"
"safeguard is used to ensure that the function always terminates, even\n"
"for complex expressions.\n"
msgstr ""

# Atensor.texi
msgid ""
"@opencatbox\n"
"@category{Package atensor} @category{Simplification functions}\n"
"@closecatbox\n"
msgstr ""

# Atensor.texi
msgid ""
"@end deffn\n"
msgstr ""

# Atensor.texi
msgid ""
"@anchor{alg_type}\n"
"@deffn {Function} alg_type\n"
"The algebra type. Valid values are @code{universal}, @code{grassmann},\n"
"@code{clifford}, @code{symmetric}, @code{symplectic} and @code{lie_envelop}.\n"
msgstr ""

# Atensor.texi
msgid ""
"@opencatbox\n"
"@category{Package atensor}\n"
"@closecatbox\n"
msgstr ""

# Atensor.texi
msgid ""
"@end deffn\n"
msgstr ""

# Atensor.texi
msgid ""
"@anchor{adim}\n"
"@defvr {Variable} adim\n"
"Default value: 0\n"
msgstr ""

# Atensor.texi
msgid ""
"The dimensionality of the algebra. @code{atensor} uses the value of @code{adim}\n"
"to determine if an indexed object is a valid base vector.  See @code{abasep}.\n"
msgstr ""

# Atensor.texi
msgid ""
"@opencatbox\n"
"@category{Package atensor} @category{Global variables}\n"
"@closecatbox\n"
msgstr ""

# Atensor.texi
msgid ""
"@end defvr\n"
msgstr ""

# Atensor.texi
msgid ""
"@anchor{aform}\n"
"@defvr {Variable} aform\n"
"Default value: @code{ident(3)}\n"
msgstr ""

# Atensor.texi
msgid ""
"Default values for the bilinear forms @code{sf}, @code{af}, and\n"
"@code{av}. The default is the identity matrix @code{ident(3)}.\n"
msgstr ""

# Atensor.texi
msgid ""
"@opencatbox\n"
"@category{Package atensor} @category{Global variables}\n"
"@closecatbox\n"
msgstr ""

# Atensor.texi
msgid ""
"@end defvr\n"
msgstr ""

# Atensor.texi
msgid ""
"@anchor{asymbol}\n"
"@defvr {Variable} asymbol\n"
"Default value: @code{v}\n"
msgstr ""

# Atensor.texi
msgid ""
"The symbol for base vectors.\n"
msgstr ""

# Atensor.texi
msgid ""
"@opencatbox\n"
"@category{Package atensor} @category{Global variables}\n"
"@closecatbox\n"
msgstr ""

# Atensor.texi
msgid ""
"@end defvr\n"
msgstr ""

# Atensor.texi
msgid ""
"@deffn {Function} sf (@var{u}, @var{v})\n"
msgstr ""

# Atensor.texi
msgid ""
"A symmetric scalar function that is used in commutation relations.\n"
"The default implementation checks if both arguments are base vectors\n"
"using @code{abasep} and if that is the case, substitutes the\n"
"corresponding value from the matrix @code{aform}.\n"
msgstr ""

# Atensor.texi
msgid ""
"@opencatbox\n"
"@category{Package atensor}\n"
"@closecatbox\n"
msgstr ""

# Atensor.texi
msgid ""
"@end deffn\n"
msgstr ""

# Atensor.texi
msgid ""
"@anchor{af}\n"
"@deffn {Function} af (@var{u}, @var{v})\n"
msgstr ""

# Atensor.texi
msgid ""
"An antisymmetric scalar function that is used in commutation relations.\n"
"The default implementation checks if both arguments are base vectors\n"
"using @code{abasep} and if that is the case, substitutes the\n"
"corresponding value from the matrix @code{aform}.\n"
msgstr ""

# Atensor.texi
msgid ""
"@opencatbox\n"
"@category{Package atensor}\n"
"@closecatbox\n"
msgstr ""

# Atensor.texi
msgid ""
"@end deffn\n"
msgstr ""

# Atensor.texi
msgid ""
"@anchor{av}\n"
"@deffn {Function} av (@var{u}, @var{v})\n"
msgstr ""

# Atensor.texi
msgid ""
"An antisymmetric function that is used in commutation relations.\n"
"The default implementation checks if both arguments are base vectors\n"
"using @code{abasep} and if that is the case, substitutes the\n"
"corresponding value from the matrix @code{aform}.\n"
msgstr ""

# Atensor.texi
msgid ""
"For instance:\n"
msgstr ""

# Atensor.texi
msgid ""
"@example\n"
"(%i1) load(atensor);\n"
"(%o1)       /share/tensor/atensor.mac\n"
"(%i2) adim:3;\n"
"(%o2)                                  3\n"
"(%i3) aform:matrix([0,3,-2],[-3,0,1],[2,-1,0]);\n"
"                               [  0    3   - 2 ]\n"
"                               [               ]\n"
"(%o3)                          [ - 3   0    1  ]\n"
"                               [               ]\n"
"                               [  2   - 1   0  ]\n"
"(%i4) asymbol:x;\n"
"(%o4)                                  x\n"
"(%i5) av(x[1],x[2]);\n"
"(%o5)                                 x\n"
"                                       3\n"
"@end example\n"
msgstr ""

# Atensor.texi
msgid ""
"@opencatbox\n"
"@category{Package atensor}\n"
"@closecatbox\n"
msgstr ""

# Atensor.texi
msgid ""
"@end deffn\n"
"@anchor{abasep}\n"
"@deffn {Function} abasep (@var{v})\n"
msgstr ""

# Atensor.texi
msgid ""
"Checks if its argument is an @code{atensor} base vector. That is, if it is\n"
"an indexed symbol, with the symbol being the same as the value of\n"
"@code{asymbol}, and the index having a numeric value between 1\n"
"and @code{adim}.\n"
msgstr ""

# Atensor.texi
msgid ""
"@opencatbox\n"
"@category{Package atensor} @category{Predicate functions}\n"
"@closecatbox\n"
msgstr ""

# Atensor.texi
msgid ""
"@end deffn\n"
msgstr ""
