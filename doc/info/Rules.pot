# This file contains all translatable strings from a .texi file.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL>, YEAR.
#
#, fuzzy
msgid ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-05-06 22:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL>\n"
"Language-Team: LANGUAGE <LL.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
msgstr ""

#: Rules.texi:5
msgid ""
"@menu\n"
"* Introduction to Rules and Patterns::  \n"
"* Functions and Variables for Rules and Patterns::  \n"
"@end menu\n"
msgstr ""

#: Rules.texi:10
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@node Introduction to Rules and Patterns, Functions and Variables for Rules and Patterns, Rules and Patterns, Rules and Patterns\n"
"@section Introduction to Rules and Patterns\n"
"@c -----------------------------------------------------------------------------\n"
msgstr ""

#: Rules.texi:18
msgid ""
"This section describes user-defined pattern matching and simplification rules.\n"
"There are two groups of functions which implement somewhat different pattern\n"
"matching schemes.  In one group are @code{tellsimp}, @code{tellsimpafter},\n"
"@code{defmatch}, @code{defrule}, @code{apply1}, @code{applyb1}, and\n"
"@code{apply2}.  In the other group are @code{let} and @code{letsimp}.\n"
"Both schemes define patterns in terms of pattern variables declared by\n"
"@code{matchdeclare}.\n"
msgstr ""

#: Rules.texi:23
msgid ""
"Pattern-matching rules defined by @code{tellsimp} and @code{tellsimpafter} are\n"
"applied automatically by the Maxima simplifier.  Rules defined by\n"
"@code{defmatch}, @code{defrule}, and @code{let} are applied by an explicit\n"
"function call.\n"
msgstr ""

#: Rules.texi:27
msgid ""
"There are additional mechanisms for rules applied to polynomials by\n"
"@code{tellrat}, and for commutative and noncommutative algebra in @code{affine}\n"
"package.\n"
msgstr ""

#: Rules.texi:31
msgid ""
"@opencatbox\n"
"@category{Simplification} @category{Rules and patterns}\n"
"@closecatbox\n"
msgstr ""

#: Rules.texi:33
msgid ""
"@c end concepts Rules and Patterns\n"
msgstr ""

#: Rules.texi:38
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@node Functions and Variables for Rules and Patterns,  , Introduction to Rules and Patterns, Rules and Patterns\n"
"@section Functions and Variables for Rules and Patterns\n"
"@c -----------------------------------------------------------------------------\n"
msgstr ""

#: Rules.texi:40
msgid ""
"@c NEEDS CLARIFICATION AND EXAMPLES\n"
msgstr ""

#: Rules.texi:44
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{apply1}\n"
"@deffn {Function} apply1 (@var{expr}, @var{rule_1}, @dots{}, @var{rule_n})\n"
msgstr ""

#: Rules.texi:52
msgid ""
"Repeatedly applies @var{rule_1} to\n"
"@var{expr} until it fails, then repeatedly applies the same rule to all\n"
"subexpressions of @var{expr}, left to right, until @var{rule_1} has failed\n"
"on all subexpressions.  Call the result of transforming @var{expr} in this\n"
"manner @var{expr_2}.  Then @var{rule_2} is applied in the same fashion\n"
"starting at the top of @var{expr_2}.  When @var{rule_n} fails on the final\n"
"subexpression, the result is returned.\n"
msgstr ""

#: Rules.texi:55
msgid ""
"@code{maxapplydepth} is the depth of the deepest subexpressions processed by\n"
"@code{apply1} and @code{apply2}.\n"
msgstr ""

#: Rules.texi:57
msgid ""
"See also @mrefcomma{applyb1} @mref{apply2} and @mrefdot{let}\n"
msgstr ""

#: Rules.texi:62
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Rules.texi:64
msgid ""
"@c NEEDS CLARIFICATION AND EXAMPLES\n"
msgstr ""

#: Rules.texi:68
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{apply2}\n"
"@deffn {Function} apply2 (@var{expr}, @var{rule_1}, @dots{}, @var{rule_n})\n"
msgstr ""

#: Rules.texi:74
msgid ""
"If @var{rule_1} fails on a given subexpression, then @var{rule_2} is\n"
"repeatedly applied, etc.  Only if all rules fail on a given\n"
"subexpression is the whole set of rules repeatedly applied to the next\n"
"subexpression.  If one of the rules succeeds, then the same\n"
"subexpression is reprocessed, starting with the first rule.\n"
msgstr ""

#: Rules.texi:77
msgid ""
"@code{maxapplydepth} is the depth of the deepest subexpressions processed by\n"
"@code{apply1} and @code{apply2}.\n"
msgstr ""

#: Rules.texi:79
msgid ""
"See also @mref{apply1} and @mrefdot{let}\n"
msgstr ""

#: Rules.texi:84
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Rules.texi:86
msgid ""
"@c NEEDS CLARIFICATION AND EXAMPLES\n"
msgstr ""

#: Rules.texi:90
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{applyb1}\n"
"@deffn {Function} applyb1 (@var{expr}, @var{rule_1}, @dots{}, @var{rule_n})\n"
msgstr ""

#: Rules.texi:97
msgid ""
"Repeatedly applies @var{rule_1} to the deepest subexpression of @var{expr}\n"
"until it fails, then repeatedly applies the same rule one level higher (i.e.,\n"
"larger subexpressions), until @var{rule_1} has failed on the top-level\n"
"expression.  Then @var{rule_2} is applied in the same fashion to the result of\n"
"@var{rule_1}.  After @var{rule_n} has been applied to the top-level expression,\n"
"the result is returned.\n"
msgstr ""

#: Rules.texi:100
msgid ""
"@code{applyb1} is similar to @code{apply1} but works from\n"
"the bottom up instead of from the top down.\n"
msgstr ""

#: Rules.texi:103
msgid ""
"@code{maxapplyheight} is the maximum height which @code{applyb1} reaches\n"
"before giving up.\n"
msgstr ""

#: Rules.texi:105
msgid ""
"See also @mrefcomma{apply1} @mref{apply2} and @mrefdot{let}\n"
msgstr ""

#: Rules.texi:110
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Rules.texi:115
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{current_let_rule_package}\n"
"@defvr {Option variable} current_let_rule_package\n"
"Default value: @code{default_let_rule_package}\n"
msgstr ""

#: Rules.texi:121
msgid ""
"@code{current_let_rule_package} is the name of the rule package that is used by\n"
"functions in the @code{let} package (@code{letsimp}, etc.) @c NEED TO GIVE AN EXPLICIT LIST HERE (NOT \\"ETC\\")\n"
"if no other rule package is specified.\n"
"This variable may be assigned the name of any rule package defined\n"
"via the @code{let} command.\n"
msgstr ""

#: Rules.texi:125
msgid ""
"If a call such as @code{letsimp (expr, rule_pkg_name)} is made,\n"
"the rule package @code{rule_pkg_name} is used for that function call only,\n"
"and the value of @code{current_let_rule_package} is not changed.\n"
msgstr ""

#: Rules.texi:130
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end defvr\n"
msgstr ""

#: Rules.texi:136
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{default_let_rule_package}\n"
"@defvr {Option variable} default_let_rule_package\n"
"@c DEFAULT BINDING OF default_let_rule_package IS default_let_rule_package (BOUND TO ITSELF)\n"
"Default value: @code{default_let_rule_package}\n"
msgstr ""

#: Rules.texi:141
msgid ""
"@c THIS IS SORT OF CONFUSING. PROBABLY NEED TO GIVE MORE DETAIL HERE\n"
"@code{default_let_rule_package} is the name of the rule package used when one\n"
"is not explicitly set by the user with @code{let} or by changing the value of\n"
"@code{current_let_rule_package}.\n"
msgstr ""

#: Rules.texi:146
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end defvr\n"
msgstr ""

#: Rules.texi:152
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{defmatch}\n"
"@deffn  {Function} defmatch @\n"
"@fname{defmatch} (@var{progname}, @var{pattern}, @var{x_1}, @dots{}, @var{x_n}) @\n"
"@fname{defmatch} (@var{progname}, @var{pattern})\n"
msgstr ""

#: Rules.texi:155
msgid ""
"Defines a function @code{@var{progname}(@var{expr}, @var{x_1}, ..., @var{x_n})}\n"
"which tests @var{expr} to see if it matches @var{pattern}.\n"
msgstr ""

#: Rules.texi:162
msgid ""
"@var{pattern} is an expression containing the pattern arguments @var{x_1},\n"
"@dots{}, @var{x_n} (if any) and some pattern variables (if any).  The pattern\n"
"arguments are given explicitly as arguments to @code{defmatch} while the pattern\n"
"variables are declared by the @code{matchdeclare} function.  Any variable not\n"
"declared as a pattern variable in @code{matchdeclare} or as a pattern argument\n"
"in @code{defmatch} matches only itself.\n"
msgstr ""

#: Rules.texi:167
msgid ""
"The first argument to the created function @var{progname} is an expression to be\n"
"matched against the pattern and the other arguments are the actual arguments\n"
"which correspond to the dummy variables @var{x_1}, @dots{}, @var{x_n} in the\n"
"pattern.\n"
msgstr ""

#: Rules.texi:174
msgid ""
"If the match is successful, @var{progname} returns a list of equations whose\n"
"left sides are the pattern arguments and pattern variables, and whose right\n"
"sides are the subexpressions which the pattern arguments and variables matched.\n"
"The pattern variables, but not the pattern arguments, are assigned the\n"
"subexpressions they match.  If the match fails, @var{progname} returns\n"
"@code{false}.\n"
msgstr ""

#: Rules.texi:177
msgid ""
"A literal pattern (that is, a pattern which contains neither pattern arguments\n"
"nor pattern variables) returns @code{true} if the match succeeds.\n"
msgstr ""

#: Rules.texi:180
msgid ""
"See also @mrefcomma{matchdeclare} @mrefcomma{defrule} @mref{tellsimp} and\n"
"@mrefdot{tellsimpafter}\n"
msgstr ""

#: Rules.texi:182
msgid ""
"Examples:\n"
msgstr ""

#: Rules.texi:189
msgid ""
"Define a function @code{linearp(expr, x)} which\n"
"tests @code{expr} to see if it is of the form @code{a*x + b}\n"
"such that @code{a} and @code{b} do not contain @code{x} and @code{a} is nonzero.\n"
"This match function matches expressions which are linear in any variable,\n"
"because the pattern argument @code{x} is given to @code{defmatch}.\n"
"@c HOW HARD WILL MAXIMA TRY TO COLLECT TERMS AND DO OTHER MUNGEING TO FIT THE PATTERN ??\n"
msgstr ""

#: Rules.texi:216
msgid ""
"@c ===beg===\n"
"@c matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b, \n"
"@c                     freeof(x));\n"
"@c defmatch (linearp, a*x + b, x);\n"
"@c linearp (3*z + (y + 1)*z + y^2, z);\n"
"@c a;\n"
"@c b;\n"
"@c x;\n"
"@c ===end===\n"
"@example\n"
"(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,\n"
"                    freeof(x));\n"
"(%o1)                         done\n"
"(%i2) defmatch (linearp, a*x + b, x);\n"
"(%o2)                        linearp\n"
"(%i3) linearp (3*z + (y + 1)*z + y^2, z);\n"
"                         2\n"
"(%o3)              [b = y , a = y + 4, x = z]\n"
"(%i4) a;\n"
"(%o4)                         y + 4\n"
"(%i5) b;\n"
"                                2\n"
"(%o5)                          y\n"
"(%i6) x;\n"
"(%o6)                           x\n"
"@end example\n"
msgstr ""

#: Rules.texi:222
msgid ""
"Define a function @code{linearp(expr)} which tests @code{expr}\n"
"to see if it is of the form @code{a*x + b}\n"
"such that @code{a} and @code{b} do not contain @code{x} and @code{a} is nonzero.\n"
"This match function only matches expressions linear in @code{x},\n"
"not any other variable, because no pattern argument is given to @code{defmatch}.\n"
msgstr ""

#: Rules.texi:242
msgid ""
"@c ===beg===\n"
"@c matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b, \n"
"@c                     freeof(x));\n"
"@c defmatch (linearp, a*x + b);\n"
"@c linearp (3*z + (y + 1)*z + y^2);\n"
"@c linearp (3*x + (y + 1)*x + y^2);\n"
"@c ===end===\n"
"@example\n"
"(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,\n"
"                    freeof(x));\n"
"(%o1)                         done\n"
"(%i2) defmatch (linearp, a*x + b);\n"
"(%o2)                        linearp\n"
"(%i3) linearp (3*z + (y + 1)*z + y^2);\n"
"(%o3)                         false\n"
"(%i4) linearp (3*x + (y + 1)*x + y^2);\n"
"                             2\n"
"(%o4)                  [b = y , a = y + 4]\n"
"@end example\n"
msgstr ""

#: Rules.texi:245
msgid ""
"Define a function @code{checklimits(expr)} which tests @code{expr}\n"
"to see if it is a definite integral.\n"
msgstr ""

#: Rules.texi:285
msgid ""
"@c ===beg===\n"
"@c matchdeclare ([a, f], true);\n"
"@c constinterval (l, h) := constantp (h - l);\n"
"@c matchdeclare (b, constinterval (a));\n"
"@c matchdeclare (x, atom);\n"
"@c simp : false;\n"
"@c defmatch (checklimits, 'integrate (f, x, a, b));\n"
"@c simp : true;\n"
"@c 'integrate (sin(t), t, %pi + x, 2*%pi + x);\n"
"@c checklimits (%);\n"
"@c ===end===\n"
"@example\n"
"(%i1) matchdeclare ([a, f], true);\n"
"(%o1)                         done\n"
"(%i2) constinterval (l, h) := constantp (h - l);\n"
"(%o2)        constinterval(l, h) := constantp(h - l)\n"
"(%i3) matchdeclare (b, constinterval (a));\n"
"(%o3)                         done\n"
"(%i4) matchdeclare (x, atom);\n"
"(%o4)                         done\n"
"(%i5) simp : false;\n"
"(%o5)                         false\n"
"(%i6) defmatch (checklimits, 'integrate (f, x, a, b));\n"
"(%o6)                      checklimits\n"
"(%i7) simp : true;\n"
"(%o7)                         true\n"
"(%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);\n"
"@group\n"
"                       x + 2 %pi\n"
"                      /\n"
"                      [\n"
"(%o8)                 I          sin(t) dt\n"
"                      ]\n"
"                      /\n"
"                       x + %pi\n"
"@end group\n"
"(%i9) checklimits (%);\n"
"(%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]\n"
"@end example\n"
msgstr ""

#: Rules.texi:290
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Rules.texi:292
msgid ""
"@c NEEDS CLARIFICATION AND EXAMPLES\n"
msgstr ""

#: Rules.texi:296
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{defrule}\n"
"@deffn {Function} defrule (@var{rulename}, @var{pattern}, @var{replacement})\n"
msgstr ""

#: Rules.texi:303
msgid ""
"Defines and names a replacement rule for the given pattern.  If the rule named\n"
"@var{rulename} is applied to an expression (by @code{apply1}, @code{applyb1}, or\n"
"@code{apply2}), every subexpression matching the pattern will be replaced by the\n"
"replacement.  All variables in the replacement which have been\n"
"assigned values by the pattern match are assigned those values in the\n"
"replacement which is then simplified.\n"
msgstr ""

#: Rules.texi:308
msgid ""
"The rules themselves can be\n"
"treated as functions which transform an expression by one\n"
"operation of the pattern match and replacement.\n"
"If the match fails, the rule function returns @code{false}.\n"
msgstr ""

#: Rules.texi:313
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Rules.texi:315
msgid ""
"@c NEEDS EXAMPLES\n"
msgstr ""

#: Rules.texi:321
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{disprule}\n"
"@deffn  {Function} disprule @\n"
"@fname{disprule} (@var{rulename_1}, @dots{}, @var{rulename_2}) @\n"
"@fname{disprule} (all)\n"
msgstr ""

#: Rules.texi:326
msgid ""
"Display rules with the names @var{rulename_1}, @dots{}, @var{rulename_n},\n"
"as returned by @code{defrule}, @code{tellsimp}, or @code{tellsimpafter},\n"
"or a pattern defined by @code{defmatch}.\n"
"Each rule is displayed with an intermediate expression label (@code{%t}).\n"
msgstr ""

#: Rules.texi:328
msgid ""
"@code{disprule (all)} displays all rules.\n"
msgstr ""

#: Rules.texi:332
msgid ""
"@code{disprule} quotes its arguments.\n"
"@code{disprule} returns the list of intermediate expression labels corresponding\n"
"to the displayed rules.\n"
msgstr ""

#: Rules.texi:334
msgid ""
"See also @mrefcomma{letrules}  which displays rules defined by @mrefdot{let}\n"
msgstr ""

#: Rules.texi:336
msgid ""
"Examples:\n"
msgstr ""

#: Rules.texi:353
msgid ""
"@c ===beg===\n"
"@c tellsimpafter (foo (x, y), bar (x) + baz (y));\n"
"@c tellsimpafter (x + y, special_add (x, y));\n"
"@c defmatch (quux, mumble (x));\n"
"@c disprule (foorule1, ?\+rule1, quux);\n"
"@c ev(%);\n"
"@c ===end===\n"
"@example\n"
"(%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));\n"
"(%o1)                   [foorule1, false]\n"
"(%i2) tellsimpafter (x + y, special_add (x, y));\n"
"(%o2)                   [+rule1, simplus]\n"
"(%i3) defmatch (quux, mumble (x));\n"
"(%o3)                         quux\n"
"(%i4) disprule (foorule1, ?\+rule1, quux);\n"
"(%t4)        foorule1 : foo(x, y) -> baz(y) + bar(x)\n"
msgstr ""

#: Rules.texi:355
msgid ""
"(%t5)          +rule1 : y + x -> special_add(x, y)\n"
msgstr ""

#: Rules.texi:357
msgid ""
"(%t6)                quux : mumble(x) -> []\n"
msgstr ""

#: Rules.texi:363
msgid ""
"(%o6)                    [%t4, %t5, %t6]\n"
"(%i6) ev(%);\n"
"(%o6) [foorule1 : foo(x, y) -> baz(y) + bar(x), \n"
"     +rule1 : y + x -> special_add(x, y), quux : mumble(x) -> []]\n"
"@end example\n"
msgstr ""

#: Rules.texi:368
msgid ""
"@opencatbox\n"
"@category{Rules and patterns} @category{Display functions}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Rules.texi:374
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{let}\n"
"@deffn  {Function} let @\n"
"@fname{let} (@var{prod}, @var{repl}, @var{predname}, @var{arg_1}, @dots{}, @var{arg_n}) @\n"
"@fname{let} ([@var{prod}, @var{repl}, @var{predname}, @var{arg_1}, @dots{}, @var{arg_n}], @var{package_name})\n"
msgstr ""

#: Rules.texi:378
msgid ""
"Defines a substitution rule for @code{letsimp} such that @var{prod} is replaced\n"
"by @var{repl}.  @var{prod} is a product of positive or negative powers of the\n"
"following terms:\n"
msgstr ""

#: Rules.texi:390
msgid ""
"@itemize @bullet\n"
"@item\n"
"Atoms which @code{letsimp} will search for literally unless previous to calling\n"
"@code{letsimp} the @code{matchdeclare} function is used to associate a\n"
"predicate with the atom.  In this case @code{letsimp} will match the atom to\n"
"any term of a product satisfying the predicate.\n"
"@item\n"
"Kernels such as @code{sin(x)}, @code{n!}, @code{f(x,y)}, etc.  As with atoms\n"
"above @code{letsimp} will look for a literal match unless @code{matchdeclare}\n"
"is used to associate a predicate with the argument of the kernel.\n"
"@end itemize\n"
msgstr ""

#: Rules.texi:397
msgid ""
"A term to a positive power will only match a term having at least that\n"
"power.  A term to a negative power\n"
"on the other hand will only match a term with a power at least as\n"
"negative.  In the case of negative powers in @var{prod} the switch\n"
"@code{letrat} must be set to @code{true}.\n"
"See also @mrefdot{letrat}\n"
msgstr ""

#: Rules.texi:407
msgid ""
"If a predicate is included in the @code{let} function followed by a list of\n"
"arguments, a tentative match (i.e. one that would be accepted if the predicate\n"
"were omitted) is accepted only if @code{predname (arg_1', ..., arg_n')}\n"
"evaluates to @code{true} where @var{arg_i'} is the value matched to @var{arg_i}.\n"
"The @var{arg_i} may be the name of any atom or the argument of any kernel\n"
"appearing in @var{prod}.\n"
"@var{repl} may be any rational expression.  @c ONLY RATIONAL -- REALLY ??\n"
"If any of the atoms or arguments from @var{prod} appear in @var{repl} the\n"
"appropriate substitutions are made.  @c SPELL OUT \\"APPROPRIATE\\" IN THIS CONTEXT\n"
msgstr ""

#: Rules.texi:414
msgid ""
"The global flag @code{letrat} controls the simplification of quotients by\n"
"@code{letsimp}.  When @code{letrat} is @code{false}, @code{letsimp} simplifies\n"
"the numerator and denominator of @var{expr} separately, and does not simplify\n"
"the quotient.  Substitutions such as @code{n!/n} goes to @code{(n-1)!} then\n"
"fail.  When @code{letrat} is @code{true}, then the numerator, denominator, and\n"
"the quotient are simplified in that order.\n"
msgstr ""

#: Rules.texi:425
msgid ""
"These substitution functions allow you to work with several rule packages at\n"
"once.  Each rule package can contain any number of @code{let} rules and is\n"
"referenced by a user-defined name.  The command @code{let ([@var{prod},\n"
"@var{repl}, @var{predname}, @var{arg_1}, ..., @var{arg_n}], @var{package_name})}\n"
"adds the rule @var{predname} to the rule package @var{package_name}.  The\n"
"command @code{letsimp (@var{expr}, @var{package_name})} applies the rules in \n"
"@var{package_name}.  @code{letsimp (@var{expr}, @var{package_name1},\n"
"@var{package_name2}, ...)} is equivalent to @code{letsimp (@var{expr},\n"
"@var{package_name1})} followed by @code{letsimp (%, @var{package_name2})},\n"
"@dots{}\n"
msgstr ""

#: Rules.texi:435
msgid ""
"@code{current_let_rule_package} is the name of the rule package that is\n"
"presently being used.  This variable may be assigned the name of any rule\n"
"package defined via the @code{let} command.  Whenever any of the functions\n"
"comprising the @code{let} package are called with no package name, the package\n"
"named by @code{current_let_rule_package} is used.  If a call such as\n"
"@code{letsimp (@var{expr}, @var{rule_pkg_name})} is made, the rule package\n"
"@var{rule_pkg_name} is used for that @code{letsimp} command only, and\n"
"@code{current_let_rule_package} is not changed.  If not otherwise specified,\n"
"@code{current_let_rule_package} defaults to @code{default_let_rule_package}.\n"
msgstr ""

#: Rules.texi:455
msgid ""
"@example\n"
"(%i1) matchdeclare ([a, a1, a2], true)$\n"
"(%i2) oneless (x, y) := is (x = y-1)$\n"
"(%i3) let (a1*a2!, a1!, oneless, a2, a1);\n"
"(%o3)         a1 a2! --> a1! where oneless(a2, a1)\n"
"(%i4) letrat: true$\n"
"(%i5) let (a1!/a1, (a1-1)!);\n"
"                        a1!\n"
"(%o5)                   --- --> (a1 - 1)!\n"
"                        a1\n"
"(%i6) letsimp (n*m!*(n-1)!/m);\n"
"(%o6)                      (m - 1)! n!\n"
"(%i7) let (sin(a)^2, 1 - cos(a)^2);\n"
"                        2               2\n"
"(%o7)                sin (a) --> 1 - cos (a)\n"
"(%i8) letsimp (sin(x)^4);\n"
"                        4           2\n"
"(%o8)                cos (x) - 2 cos (x) + 1\n"
"@end example\n"
msgstr ""

#: Rules.texi:461
msgid ""
"@c NEEDS ADDITIONAL EXAMPLES\n"
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Rules.texi:466
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{letrat}\n"
"@defvr {Option variable} letrat\n"
"Default value: @code{false}\n"
msgstr ""

#: Rules.texi:470
msgid ""
"When @code{letrat} is @code{false}, @code{letsimp} simplifies the\n"
"numerator and denominator of a ratio separately,\n"
"and does not simplify the quotient.\n"
msgstr ""

#: Rules.texi:473
msgid ""
"When @code{letrat} is @code{true},\n"
"the numerator, denominator, and their quotient are simplified in that order.\n"
msgstr ""

#: Rules.texi:489
msgid ""
"@example\n"
"(%i1) matchdeclare (n, true)$\n"
"(%i2) let (n!/n, (n-1)!);\n"
"                         n!\n"
"(%o2)                    -- --> (n - 1)!\n"
"                         n\n"
"(%i3) letrat: false$\n"
"(%i4) letsimp (a!/a);\n"
"                               a!\n"
"(%o4)                          --\n"
"                               a\n"
"(%i5) letrat: true$\n"
"(%i6) letsimp (a!/a);\n"
"(%o6)                       (a - 1)!\n"
"@end example\n"
msgstr ""

#: Rules.texi:494
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end defvr\n"
msgstr ""

#: Rules.texi:496
msgid ""
"@c NEEDS EXAMPLES\n"
msgstr ""

#: Rules.texi:502
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{letrules}\n"
"@deffn  {Function} letrules @\n"
"@fname{letrules} () @\n"
"@fname{letrules} (@var{package_name})\n"
msgstr ""

#: Rules.texi:506
msgid ""
"Displays the rules in a rule package.\n"
"@code{letrules ()} displays the rules in the current rule package.\n"
"@code{letrules (@var{package_name})} displays the rules in @var{package_name}.\n"
msgstr ""

#: Rules.texi:510
msgid ""
"The current rule package is named by @code{current_let_rule_package}.\n"
"If not otherwise specified, @code{current_let_rule_package}\n"
"defaults to @code{default_let_rule_package}.\n"
msgstr ""

#: Rules.texi:514
msgid ""
"See also @mrefcomma{disprule} which displays rules defined by @mref{tellsimp} and\n"
"@mrefdot{tellsimpafter}\n"
"@c WHAT ABOUT defmatch AND defrule ??\n"
msgstr ""

#: Rules.texi:519
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Rules.texi:526
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{letsimp}\n"
"@deffn  {Function} letsimp @\n"
"@fname{letsimp} (@var{expr}) @\n"
"@fname{letsimp} (@var{expr}, @var{package_name}) @\n"
"@fname{letsimp} (@var{expr}, @var{package_name_1}, @dots{}, @var{package_name_n})\n"
msgstr ""

#: Rules.texi:529
msgid ""
"Repeatedly applies the substitution rules defined by @code{let}\n"
"until no further change is made to @var{expr}.\n"
msgstr ""

#: Rules.texi:531
msgid ""
"@code{letsimp (@var{expr})} uses the rules from @code{current_let_rule_package}.\n"
msgstr ""

#: Rules.texi:534
msgid ""
"@code{letsimp (@var{expr}, @var{package_name})} uses the rules from\n"
"@var{package_name} without changing @code{current_let_rule_package}.\n"
msgstr ""

#: Rules.texi:538
msgid ""
"@code{letsimp (@var{expr}, @var{package_name_1}, ..., @var{package_name_n})}\n"
"is equivalent to @code{letsimp (@var{expr}, @var{package_name_1})},\n"
"followed by @code{letsimp (%, @var{package_name_2})}, and so on.\n"
msgstr ""

#: Rules.texi:544
msgid ""
"@c NEEDS EXAMPLES\n"
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Rules.texi:549
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{let_rule_packages}\n"
"@defvr {Option variable} let_rule_packages\n"
"Default value: @code{[default_let_rule_package]}\n"
msgstr ""

#: Rules.texi:552
msgid ""
"@code{let_rule_packages} is a list of all user-defined let rule packages\n"
"plus the default package @code{default_let_rule_package}.\n"
msgstr ""

#: Rules.texi:557
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end defvr\n"
msgstr ""

#: Rules.texi:561
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{matchdeclare}\n"
"@deffn {Function} matchdeclare (@var{a_1}, @var{pred_1}, @dots{}, @var{a_n}, @var{pred_n})\n"
msgstr ""

#: Rules.texi:566
msgid ""
"Associates a predicate @var{pred_k} \n"
"with a variable or list of variables @var{a_k}\n"
"so that @var{a_k} matches expressions\n"
"for which the predicate returns anything other than @code{false}.\n"
msgstr ""

#: Rules.texi:579
msgid ""
"A predicate is the name of a function,\n"
"or a lambda expression,\n"
"or a function call or lambda call missing the last argument,\n"
"or @code{true} or @code{all}.\n"
"Any expression matches @code{true} or @code{all}.\n"
"If the predicate is specified as a function call or lambda call,\n"
"the expression to be tested is appended to the list of arguments;\n"
"the arguments are evaluated at the time the match is evaluated.\n"
"Otherwise, the predicate is specified as a function name or lambda expression,\n"
"and the expression to be tested is the sole argument.\n"
"A predicate function need not be defined when @code{matchdeclare} is called;\n"
"the predicate is not evaluated until a match is attempted.\n"
msgstr ""

#: Rules.texi:584
msgid ""
"A predicate may return a Boolean expression as well as @code{true} or\n"
"@code{false}.  Boolean expressions are evaluated by @code{is} within the\n"
"constructed rule function, so it is not necessary to call @code{is} within the\n"
"predicate.\n"
msgstr ""

#: Rules.texi:591
msgid ""
"If an expression satisfies a match predicate, the match variable is assigned the\n"
"expression, except for match variables which are operands of addition @code{+}\n"
"or multiplication @code{*}.  Only addition and multiplication are handled\n"
"specially; other n-ary operators (both built-in and user-defined) are treated\n"
"like ordinary functions.\n"
"@c WOULD BE GREAT TO EXTEND PART+/PART* PROCESSING TO ALL N-ARY OPERATORS\n"
msgstr ""

#: Rules.texi:602
msgid ""
"In the case of addition and multiplication, the match variable may be assigned a\n"
"single expression which satisfies the match predicate, or a sum or product\n"
"(respectively) of such expressions.  Such multiple-term matching is greedy:\n"
"predicates are evaluated in the order in which their associated variables\n"
"appear in the match pattern, and a term which satisfies more than one predicate\n"
"is taken by the first predicate which it satisfies.  Each predicate is tested\n"
"against all operands of the sum or product before the next predicate is\n"
"evaluated.  In addition, if 0 or 1 (respectively) satisfies a match predicate,\n"
"and there are no other terms which satisfy the predicate, 0 or 1 is assigned to\n"
"the match variable associated with the predicate.\n"
msgstr ""

#: Rules.texi:609
msgid ""
"The algorithm for processing addition and multiplication patterns makes some\n"
"match results (for example, a pattern in which a \\"match anything\\" variable\n"
"appears) dependent on the ordering of terms in the match pattern and in the\n"
"expression to be matched.  However, if all match predicates are mutually\n"
"exclusive, the match result is insensitive to ordering, as one match predicate\n"
"cannot accept terms matched by another.\n"
msgstr ""

#: Rules.texi:615
msgid ""
"Calling @code{matchdeclare} with a variable @var{a} as an argument changes the\n"
"@code{matchdeclare} property for @var{a}, if one was already declared; only the\n"
"most recent @code{matchdeclare} is in effect when a rule is defined.  Later\n"
"changes to the @code{matchdeclare} property (via @code{matchdeclare} or\n"
"@code{remove}) do not affect existing rules.\n"
msgstr ""

#: Rules.texi:622
msgid ""
"@code{propvars (matchdeclare)} returns the list of all variables for which there\n"
"is a @code{matchdeclare} property.  @code{printprops (@var{a}, matchdeclare)}\n"
"returns the predicate for variable @code{a}.\n"
"@code{printprops (all, matchdeclare)} returns the list of predicates for all\n"
"@code{matchdeclare} variables.  @code{remove (@var{a}, matchdeclare)} removes\n"
"the @code{matchdeclare} property from @var{a}.\n"
msgstr ""

#: Rules.texi:626
msgid ""
"The functions @code{defmatch}, @code{defrule}, @code{tellsimp},\n"
"@code{tellsimpafter}, and @code{let} construct rules which test expressions\n"
"against patterns.\n"
msgstr ""

#: Rules.texi:629
msgid ""
"@code{matchdeclare} quotes its arguments.\n"
"@code{matchdeclare} always returns @code{done}.\n"
msgstr ""

#: Rules.texi:631
msgid ""
"Examples:\n"
msgstr ""

#: Rules.texi:636
msgid ""
"A predicate is the name of a function,\n"
"or a lambda expression,\n"
"or a function call or lambda call missing the last argument,\n"
"or @code{true} or @code{all}.\n"
msgstr ""

#: Rules.texi:659
msgid ""
"@c ===beg===\n"
"@c matchdeclare (aa, integerp);\n"
"@c matchdeclare (bb, lambda ([x], x > 0));\n"
"@c matchdeclare (cc, freeof (%e, %pi, %i));\n"
"@c matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));\n"
"@c matchdeclare (ee, true);\n"
"@c matchdeclare (ff, all);\n"
"@c ===end===\n"
"@example\n"
"(%i1) matchdeclare (aa, integerp);\n"
"(%o1)                         done\n"
"(%i2) matchdeclare (bb, lambda ([x], x > 0));\n"
"(%o2)                         done\n"
"(%i3) matchdeclare (cc, freeof (%e, %pi, %i));\n"
"(%o3)                         done\n"
"(%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));\n"
"(%o4)                         done\n"
"(%i5) matchdeclare (ee, true);\n"
"(%o5)                         done\n"
"(%i6) matchdeclare (ff, all);\n"
"(%o6)                         done\n"
"@end example\n"
msgstr ""

#: Rules.texi:662
msgid ""
"If an expression satisfies a match predicate,\n"
"the match variable is assigned the expression.\n"
msgstr ""

#: Rules.texi:677
msgid ""
"@c ===beg===\n"
"@c matchdeclare (aa, integerp, bb, atom);\n"
"@c defrule (r1, bb^aa, [\\"integer\\" = aa, \\"atom\\" = bb]);\n"
"@c r1 (%pi^8);\n"
"@c ===end===\n"
"@example\n"
"(%i1) matchdeclare (aa, integerp, bb, atom);\n"
"(%o1)                         done\n"
"(%i2) defrule (r1, bb^aa, [\\"integer\\" = aa, \\"atom\\" = bb]);\n"
"                    aa\n"
"(%o2)        r1 : bb   -> [integer = aa, atom = bb]\n"
"(%i3) r1 (%pi^8);\n"
"(%o3)               [integer = 8, atom = %pi]\n"
"@end example\n"
msgstr ""

#: Rules.texi:681
msgid ""
"In the case of addition and multiplication, the match variable may be assigned\n"
"a single expression which satisfies the match predicate, or a sum or product\n"
"(respectively) of such expressions.\n"
msgstr ""

#: Rules.texi:707
msgid ""
"@c ===beg===\n"
"@c matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));\n"
"@c defrule (r1, aa + bb, [\\"all atoms\\" = aa, \\"all nonatoms\\" = \n"
"@c                bb]);\n"
"@c r1 (8 + a*b + sin(x));\n"
"@c defrule (r2, aa * bb, [\\"all atoms\\" = aa, \\"all nonatoms\\" = \n"
"@c                bb]);\n"
"@c r2 (8 * (a + b) * sin(x));\n"
"@c ===end===\n"
"@example\n"
"(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));\n"
"(%o1)                         done\n"
"(%i2) defrule (r1, aa + bb, [\\"all atoms\\" = aa, \\"all nonatoms\\" =\n"
"               bb]);\n"
"bb + aa partitions `sum'\n"
"(%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]\n"
"(%i3) r1 (8 + a*b + sin(x));\n"
"(%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]\n"
"(%i4) defrule (r2, aa * bb, [\\"all atoms\\" = aa, \\"all nonatoms\\" =\n"
"               bb]);\n"
"bb aa partitions `product'\n"
"(%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]\n"
"(%i5) r2 (8 * (a + b) * sin(x));\n"
"(%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]\n"
"@end example\n"
msgstr ""

#: Rules.texi:712
msgid ""
"When matching arguments of @code{+} and @code{*},\n"
"if all match predicates are mutually exclusive,\n"
"the match result is insensitive to ordering,\n"
"as one match predicate cannot accept terms matched by another.\n"
msgstr ""

#: Rules.texi:742
msgid ""
"@c ===beg===\n"
"@c matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));\n"
"@c defrule (r1, aa + bb, [\\"all atoms\\" = aa, \\"all nonatoms\\" = \n"
"@c                bb]);\n"
"@c r1 (8 + a*b + %pi + sin(x) - c + 2^n);\n"
"@c defrule (r2, aa * bb, [\\"all atoms\\" = aa, \\"all nonatoms\\" = \n"
"@c                bb]);\n"
"@c r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);\n"
"@c ===end===\n"
"@example\n"
"(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));\n"
"(%o1)                         done\n"
"(%i2) defrule (r1, aa + bb, [\\"all atoms\\" = aa, \\"all nonatoms\\" =\n"
"               bb]);\n"
"bb + aa partitions `sum'\n"
"(%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]\n"
"(%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);\n"
"                                                     n\n"
"(%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]\n"
"(%i4) defrule (r2, aa * bb, [\\"all atoms\\" = aa, \\"all nonatoms\\" =\n"
"               bb]);\n"
"bb aa partitions `product'\n"
"(%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]\n"
"(%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);\n"
"                                                  n\n"
"                                         (b + a) 2  sin(x)\n"
"(%o5) [all atoms = 8 %pi, all nonatoms = -----------------]\n"
"                                                 c\n"
"@end example\n"
msgstr ""

#: Rules.texi:745
msgid ""
"The functions @code{propvars} and @code{printprops} return information about\n"
"match variables.\n"
msgstr ""

#: Rules.texi:769
msgid ""
"@c ===beg===\n"
"@c matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);\n"
"@c matchdeclare (ff, floatnump, gg, lambda ([x], x > 100));\n"
"@c propvars (matchdeclare);\n"
"@c printprops (ee, matchdeclare);\n"
"@c printprops (gg, matchdeclare);\n"
"@c printprops (all, matchdeclare);\n"
"@c ===end===\n"
"@example\n"
"(%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);\n"
"(%o1)                         done\n"
"(%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x > 100));\n"
"(%o2)                         done\n"
"(%i3) propvars (matchdeclare);\n"
"(%o3)             [aa, bb, cc, dd, ee, ff, gg]\n"
"(%i4) printprops (ee, matchdeclare);\n"
"(%o4)                    [integerp(ee)]\n"
"(%i5) printprops (gg, matchdeclare);\n"
"(%o5)              [lambda([x], x > 100, gg)]\n"
"(%i6) printprops (all, matchdeclare);\n"
"(%o6) [lambda([x], x > 100, gg), floatnump(ff), integerp(ee), \n"
"                      integerp(dd), atom(cc), atom(bb), atom(aa)]\n"
"@end example\n"
msgstr ""

#: Rules.texi:774
msgid ""
"@opencatbox\n"
"@category{Rules and patterns} @category{Declarations and inferences}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Rules.texi:776
msgid ""
"@c NEEDS EXAMPLES\n"
msgstr ""

#: Rules.texi:781
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{maxapplydepth}\n"
"@defvr {Option variable} maxapplydepth\n"
"Default value: 10000\n"
msgstr ""

#: Rules.texi:784
msgid ""
"@code{maxapplydepth} is the maximum depth to which @code{apply1}\n"
"and @code{apply2} will delve.\n"
msgstr ""

#: Rules.texi:789
msgid ""
"@opencatbox\n"
"@category{Function application}\n"
"@closecatbox\n"
"@end defvr\n"
msgstr ""

#: Rules.texi:791
msgid ""
"@c NEEDS EXAMPLES\n"
msgstr ""

#: Rules.texi:796
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{maxapplyheight}\n"
"@defvr {Option variable} maxapplyheight\n"
"Default value: 10000\n"
msgstr ""

#: Rules.texi:799
msgid ""
"@code{maxapplyheight} is the maximum height to which @code{applyb1}\n"
"will reach before giving up.\n"
msgstr ""

#: Rules.texi:804
msgid ""
"@opencatbox\n"
"@category{Function application}\n"
"@closecatbox\n"
"@end defvr\n"
msgstr ""

#: Rules.texi:806
msgid ""
"@c NEEDS CLARIFICATION AND EXAMPLES\n"
msgstr ""

#: Rules.texi:814
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{remlet}\n"
"@deffn  {Function} remlet @\n"
"@fname{remlet} (@var{prod}, @var{name}) @\n"
"@fname{remlet} () @\n"
"@fname{remlet} (all) @\n"
"@fname{remlet} (all, @var{name})\n"
msgstr ""

#: Rules.texi:818
msgid ""
"Deletes the substitution rule, @var{prod} --> repl, most\n"
"recently defined by the @code{let} function.  If name is supplied the rule is\n"
"deleted from the rule package name.\n"
msgstr ""

#: Rules.texi:822
msgid ""
"@code{remlet()} and @code{remlet(all)} delete all substitution rules from the\n"
"current rule package.  If the name of a rule package is supplied, e.g.\n"
"@code{remlet (all, @var{name})}, the rule package @var{name} is also deleted.\n"
msgstr ""

#: Rules.texi:828
msgid ""
"If a substitution is to be changed using the same\n"
"product, @code{remlet} need not be called, just redefine the substitution\n"
"using the same product (literally) with the @code{let} function and the new\n"
"replacement and/or predicate name.  Should @code{remlet (@var{prod})} now be\n"
"called the original substitution rule is revived.\n"
msgstr ""

#: Rules.texi:831
msgid ""
"See also @mrefcomma{remrule} which removes a rule defined by @mref{tellsimp} or\n"
"@mrefdot{tellsimpafter}\n"
msgstr ""

#: Rules.texi:836
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Rules.texi:842
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{remrule}\n"
"@deffn  {Function} remrule @\n"
"@fname{remrule} (@var{op}, @var{rulename}) @\n"
"@fname{remrule} (@var{op}, all)\n"
msgstr ""

#: Rules.texi:844
msgid ""
"Removes rules defined by @code{tellsimp} or @code{tellsimpafter}.\n"
msgstr ""

#: Rules.texi:850
msgid ""
"@code{remrule (@var{op}, @var{rulename})}\n"
"removes the rule with the name @var{rulename} from the operator @var{op}.\n"
"When @var{op} is a built-in or user-defined operator\n"
"(as defined by @code{infix}, @code{prefix}, etc.),\n"
"@var{op} and @var{rulename} must be enclosed in double quote marks.\n"
msgstr ""

#: Rules.texi:852
msgid ""
"@code{remrule (@var{op}, all)} removes all rules for the operator @var{op}.\n"
msgstr ""

#: Rules.texi:854
msgid ""
"See also @mrefcomma{remlet} which removes a rule defined by @mrefdot{let}\n"
msgstr ""

#: Rules.texi:856
msgid ""
"Examples:\n"
msgstr ""

#: Rules.texi:904
msgid ""
"@c ===beg===\n"
"@c tellsimp (foo (aa, bb), bb - aa);\n"
"@c tellsimpafter (aa + bb, special_add (aa, bb));\n"
"@c infix (\\"@@\\");\n"
"@c tellsimp (aa @@ bb, bb/aa);\n"
"@c tellsimpafter (quux (%pi, %e), %pi - %e);\n"
"@c tellsimpafter (quux (%e, %pi), %pi + %e);\n"
"@c [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e), \n"
"@c        quux (%e, %pi)];\n"
"@c remrule (foo, foorule1);\n"
"@c remrule (\\"+\\", ?\+rule1);\n"
"@c remrule (\\"@@\\", ?\@\@rule1);\n"
"@c remrule (quux, all);\n"
"@c [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e), \n"
"@c         quux (%e, %pi)];\n"
"@c ===end===\n"
"@example\n"
"(%i1) tellsimp (foo (aa, bb), bb - aa);\n"
"(%o1)                   [foorule1, false]\n"
"(%i2) tellsimpafter (aa + bb, special_add (aa, bb));\n"
"(%o2)                   [+rule1, simplus]\n"
"(%i3) infix (\\"@@@@\\");\n"
"(%o3)                          @@@@\n"
"(%i4) tellsimp (aa @@@@ bb, bb/aa);\n"
"(%o4)                   [@@@@rule1, false]\n"
"(%i5) tellsimpafter (quux (%pi, %e), %pi - %e);\n"
"(%o5)                  [quuxrule1, false]\n"
"(%i6) tellsimpafter (quux (%e, %pi), %pi + %e);\n"
"(%o6)             [quuxrule2, quuxrule1, false]\n"
"(%i7) [foo (aa, bb), aa + bb, aa @@@@ bb, quux (%pi, %e),\n"
"       quux (%e, %pi)];\n"
"                                     bb\n"
"(%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]\n"
"                                     aa\n"
"(%i8) remrule (foo, foorule1);\n"
"(%o8)                          foo\n"
"(%i9) remrule (\\"+\\", ?\+rule1);\n"
"(%o9)                           +\n"
"(%i10) remrule (\\"@@@@\\", ?\@@\@@rule1);\n"
"(%o10)                         @@@@\n"
"(%i11) remrule (quux, all);\n"
"(%o11)                        quux\n"
"(%i12) [foo (aa, bb), aa + bb, aa @@@@ bb, quux (%pi, %e),\n"
"        quux (%e, %pi)];\n"
"(%o12) [foo(aa, bb), bb + aa, aa @@@@ bb, quux(%pi, %e), \n"
"                                         quux(%e, %pi)]\n"
"@end example\n"
msgstr ""

#: Rules.texi:909
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Rules.texi:911
msgid ""
"@c NEEDS EXPANSION OR MAYBE JUST APPROPRIATE REFS TO tellsimpafter\n"
msgstr ""

#: Rules.texi:915
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{tellsimp}\n"
"@deffn {Function} tellsimp (@var{pattern}, @var{replacement})\n"
msgstr ""

#: Rules.texi:919
msgid ""
"is similar to @code{tellsimpafter} but places\n"
"new information before old so that it is applied before the built-in\n"
"simplification rules.\n"
msgstr ""

#: Rules.texi:927
msgid ""
"@code{tellsimp} is used when it is important to modify\n"
"the expression before the simplifier works on it, for instance if the\n"
"simplifier \\"knows\\" something about the expression, but what it returns\n"
"is not to your liking.\n"
"If the simplifier \\"knows\\" something about the\n"
"main operator of the expression, but is simply not doing enough for\n"
"you, you probably want to use @code{tellsimpafter}.\n"
msgstr ""

#: Rules.texi:930
msgid ""
"The pattern may not be a\n"
"sum, product, single variable, or number.\n"
msgstr ""

#: Rules.texi:933
msgid ""
"The system variable @code{rules} is the list of rules defined by\n"
"@code{defrule}, @code{defmatch}, @code{tellsimp}, and @code{tellsimpafter}.\n"
msgstr ""

#: Rules.texi:935
msgid ""
"Examples:\n"
msgstr ""

#: Rules.texi:976
msgid ""
"@example\n"
"(%i1) matchdeclare (x, freeof (%i));\n"
"(%o1)                         done\n"
"(%i2) %iargs: false$\n"
"(%i3) tellsimp (sin(%i*x), %i*sinh(x));\n"
"(%o3)                 [sinrule1, simp-%sin]\n"
"(%i4) trigexpand (sin (%i*y + x));\n"
"(%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)\n"
"(%i5) %iargs:true$\n"
"(%i6) errcatch(0^0);\n"
" 0\n"
"0  has been generated\n"
"(%o6)                          []\n"
"(%i7) ev (tellsimp (0^0, 1), simp: false);\n"
"(%o7)                  [^rule1, simpexpt]\n"
"(%i8) 0^0;\n"
"(%o8)                           1\n"
"(%i9) remrule (\\"^\\", %th(2)[1]);\n"
"(%o9)                           ^\n"
"(%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);\n"
"(%o10)                 [^rule2, simpexpt]\n"
"(%i11) (1 + sin(x))^2;\n"
"                                      2\n"
"(%o11)                    (sin(x) + 1)\n"
"(%i12) expand (%);\n"
"                                   2\n"
"(%o12)               2 sin(x) - cos (x) + 2\n"
"(%i13) sin(x)^2;\n"
"                                  2\n"
"(%o13)                     1 - cos (x)\n"
"(%i14) kill (rules);\n"
"(%o14)                        done\n"
"(%i15) matchdeclare (a, true);\n"
"(%o15)                        done\n"
"(%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);\n"
"(%o16)                 [^rule3, simpexpt]\n"
"(%i17) sin(y)^2;\n"
"                                  2\n"
"(%o17)                     1 - cos (y)\n"
"@end example\n"
msgstr ""

#: Rules.texi:981
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Rules.texi:985
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{tellsimpafter}\n"
"@deffn {Function} tellsimpafter (@var{pattern}, @var{replacement})\n"
msgstr ""

#: Rules.texi:993
msgid ""
"Defines a simplification rule which the Maxima simplifier applies after built-in\n"
"simplification rules.  @var{pattern} is an expression, comprising pattern\n"
"variables (declared by @code{matchdeclare}) and other atoms and operators,\n"
"considered literals for the purpose of pattern matching.  @var{replacement} is\n"
"substituted for an actual expression which matches @var{pattern}; pattern\n"
"variables in @var{replacement} are assigned the values matched in the actual\n"
"expression.\n"
msgstr ""

#: Rules.texi:1002
msgid ""
"@var{pattern} may be any nonatomic expression in which the main operator is not\n"
"a pattern variable; the simplification rule is associated with the main\n"
"operator.  The names of functions (with one exception, described below), lists,\n"
"and arrays may appear in @var{pattern} as the main operator only as literals\n"
"(not pattern variables); this rules out expressions such as @code{aa(x)} and\n"
"@code{bb[y]} as patterns, if @code{aa} and @code{bb} are pattern variables.\n"
"Names of functions, lists, and arrays which are pattern variables may appear as\n"
"operators other than the main operator in @var{pattern}.\n"
msgstr ""

#: Rules.texi:1008
msgid ""
"There is one exception to the above rule concerning names of functions.\n"
"The name of a subscripted function in an expression such as @code{aa[x](y)}\n"
"may be a pattern variable, because the main operator is not @code{aa} but rather\n"
"the Lisp atom @code{mqapply}.  This is a consequence of the representation of\n"
"expressions involving subscripted functions.\n"
msgstr ""

#: Rules.texi:1015
msgid ""
"@c LET'S NOT GO INTO DETAILS ABOUT MAIN OPERATORS HERE; BUT PRESERVE THIS FOR REFERENCE\n"
"@c The main operator of an expression @code{expr} is @code{caar $expr}.\n"
"@c For most kinds of expressions,\n"
"@c the main operator is the operator returned by @code{op (@var{pattern})};\n"
"@c the sole exception is the operator @code{mqapply},\n"
"@c which appears in indexed function expressions (e.g., @code{foo[i](x)}).\n"
msgstr ""

#: Rules.texi:1028
msgid ""
"@c NEED TO REVIEW THIS PARAGRAPH FOR ACCURACY\n"
"Simplification rules are applied after evaluation \n"
"(if not suppressed through quotation or the flag @code{noeval}).\n"
"Rules established by @code{tellsimpafter} are applied in the order they were\n"
"defined, and after any built-in rules.\n"
"Rules are applied bottom-up, that is,\n"
"applied first to subexpressions before application to the whole expression.\n"
"@c NO IT IS MORE COMPLICATED THAN THIS, ALTHOUGH IN SOME CIRCUMSTANCE IT APPEARS TO BE THE CASE:\n"
"@c For a given expression, at most one rule per operator is applied.\n"
"It may be necessary to repeatedly simplify a result (for example, via the\n"
"quote-quote operator @code{'@w{}'} or the flag @code{infeval})\n"
"to ensure that all rules are applied.\n"
msgstr ""

#: Rules.texi:1036
msgid ""
"Pattern variables are treated as local variables in simplification rules.\n"
"Once a rule is defined, the value of a pattern variable\n"
"does not affect the rule, and is not affected by the rule.\n"
"An assignment to a pattern variable which results from a successful rule match\n"
"does not affect the current assignment (or lack of it) of the pattern variable.\n"
"However, as with all atoms in Maxima, the properties of pattern variables (as\n"
"declared by @code{put} and related functions) are global.\n"
msgstr ""

#: Rules.texi:1046
msgid ""
"The rule constructed by @code{tellsimpafter} is named after the main operator of\n"
"@var{pattern}.  Rules for built-in operators, and user-defined operators defined\n"
"by @code{infix}, @code{prefix}, @code{postfix}, @code{matchfix}, and\n"
"@code{nofix}, have names which are Lisp identifiers.\n"
"@c SLIGHTLY TOO MUCH DETAIL\n"
"@c (that is, the name is written with a leading question mark @code{?} in Maxima).\n"
"Rules for other functions have names which are Maxima identifiers.\n"
"@c SLIGHTLY TOO MUCH DETAIL\n"
"@c (that is, the name begins with dollar sign @code{$}).\n"
msgstr ""

#: Rules.texi:1053
msgid ""
"The treatment of noun and verb forms is slightly confused.  @c THIS IS A BUG.\n"
"If a rule is defined for a noun (or verb) form\n"
"and a rule for the corresponding verb (or noun) form already exists, \n"
"the newly-defined rule applies to both forms (noun and verb).\n"
"If a rule for the corresponding verb (or noun) form does not exist,\n"
"the newly-defined rule applies only to the noun (or verb) form.\n"
msgstr ""

#: Rules.texi:1058
msgid ""
"The rule constructed by @code{tellsimpafter} is an ordinary Lisp function.\n"
"If the name of the rule is @code{$foorule1},\n"
"the construct @code{:lisp (trace $foorule1)} traces the function,\n"
"and @code{:lisp (symbol-function '$foorule1)} displays its definition.\n"
msgstr ""

#: Rules.texi:1063
msgid ""
"@code{tellsimpafter} quotes its arguments.\n"
"@code{tellsimpafter} returns the list of rules for the main operator of\n"
"@var{pattern}, including the newly established rule.\n"
"@c WHAT IS simpfoo THAT SOMETIMES APPEARS, AND WHY DOES false SOMETIMES APPEAR IN RETURN VALUE ??\n"
msgstr ""

#: Rules.texi:1066
msgid ""
"See also @mrefcomma{matchdeclare} @mrefcomma{defmatch} @mrefcomma{defrule} @mrefcomma{tellsimp}\n"
"@mrefcomma{let} @mrefcomma{kill} @mref{remrule} and @mrefdot{clear_rules}\n"
msgstr ""

#: Rules.texi:1068
msgid ""
"Examples:\n"
msgstr ""

#: Rules.texi:1071
msgid ""
"@var{pattern} may be any nonatomic expression in which the \n"
"main operator is not a pattern variable.\n"
msgstr ""

#: Rules.texi:1099
msgid ""
"@c ===beg===\n"
"@c matchdeclare (aa, atom, [ll, mm], listp, xx, true)$\n"
"@c tellsimpafter (sin (ll), map (sin, ll));\n"
"@c sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);\n"
"@c tellsimpafter (ll^mm, map (\\"^\\", ll, mm));\n"
"@c [a, b, c]^[1, 2, 3];\n"
"@c tellsimpafter (foo (aa (xx)), aa (foo (xx)));\n"
"@c foo (bar (u - v));\n"
"@c ===end===\n"
"@example\n"
"(%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$\n"
"(%i2) tellsimpafter (sin (ll), map (sin, ll));\n"
"(%o2)                 [sinrule1, simp-%sin]\n"
"(%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);\n"
"                    1  sqrt(2)  sqrt(3)\n"
"(%o3)              [-, -------, -------, 1, 0]\n"
"                    2     2        2\n"
"(%i4) tellsimpafter (ll^mm, map (\\"^\\", ll, mm));\n"
"(%o4)                  [^rule1, simpexpt]\n"
"(%i5) [a, b, c]^[1, 2, 3];\n"
"                                2   3\n"
"(%o5)                      [a, b , c ]\n"
"(%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));\n"
"(%o6)                   [foorule1, false]\n"
"(%i7) foo (bar (u - v));\n"
"(%o7)                    bar(foo(u - v))\n"
"@end example\n"
msgstr ""

#: Rules.texi:1103
msgid ""
"Rules are applied in the order they were defined.\n"
"If two rules can match an expression,\n"
"the rule which was defined first is applied.\n"
msgstr ""

#: Rules.texi:1120
msgid ""
"@c ===beg===\n"
"@c matchdeclare (aa, integerp);\n"
"@c tellsimpafter (foo (aa), bar_1 (aa));\n"
"@c tellsimpafter (foo (aa), bar_2 (aa));\n"
"@c foo (42);\n"
"@c ===end===\n"
"@example\n"
"(%i1) matchdeclare (aa, integerp);\n"
"(%o1)                         done\n"
"(%i2) tellsimpafter (foo (aa), bar_1 (aa));\n"
"(%o2)                   [foorule1, false]\n"
"(%i3) tellsimpafter (foo (aa), bar_2 (aa));\n"
"(%o3)              [foorule2, foorule1, false]\n"
"(%i4) foo (42);\n"
"(%o4)                       bar_1(42)\n"
"@end example\n"
msgstr ""

#: Rules.texi:1124
msgid ""
"Pattern variables are treated as local variables in simplification rules.\n"
"(Compare to @code{defmatch}, which treats pattern variables as global\n"
"variables.)\n"
msgstr ""

#: Rules.texi:1144
msgid ""
"@c ===beg===\n"
"@c matchdeclare (aa, integerp, bb, atom);\n"
"@c tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));\n"
"@c bb: 12345;\n"
"@c foo (42, %e);\n"
"@c bb;\n"
"@c ===end===\n"
"@example\n"
"(%i1) matchdeclare (aa, integerp, bb, atom);\n"
"(%o1)                         done\n"
"(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));\n"
"(%o2)                   [foorule1, false]\n"
"(%i3) bb: 12345;\n"
"(%o3)                         12345\n"
"(%i4) foo (42, %e);\n"
"(%o4)                 bar(aa = 42, bb = %e)\n"
"(%i5) bb;\n"
"(%o5)                         12345\n"
"@end example\n"
msgstr ""

#: Rules.texi:1149
msgid ""
"As with all atoms, properties of pattern variables are global even though values\n"
"are local.  In this example, an assignment property is declared via\n"
"@code{define_variable}.  This is a property of the atom @code{bb} throughout\n"
"Maxima.\n"
msgstr ""

#: Rules.texi:1170
msgid ""
"@c ===beg===\n"
"@c matchdeclare (aa, integerp, bb, atom);\n"
"@c tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));\n"
"@c foo (42, %e);\n"
"@c define_variable (bb, true, boolean);\n"
"@c foo (42, %e);\n"
"@c ===end===\n"
"@example\n"
"(%i1) matchdeclare (aa, integerp, bb, atom);\n"
"(%o1)                         done\n"
"(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));\n"
"(%o2)                   [foorule1, false]\n"
"(%i3) foo (42, %e);\n"
"(%o3)                 bar(aa = 42, bb = %e)\n"
"(%i4) define_variable (bb, true, boolean);\n"
"(%o4)                         true\n"
"(%i5) foo (42, %e);\n"
"Error: bb was declared mode boolean, has value: %e\n"
" -- an error.  Quitting.  To debug this try debugmode(true);\n"
"@end example\n"
msgstr ""

#: Rules.texi:1174
msgid ""
"Rules are named after main operators.\n"
"Names of rules for built-in and user-defined operators are Lisp identifiers,\n"
"while names for other functions are Maxima identifiers.\n"
msgstr ""

#: Rules.texi:1215
msgid ""
"@c ===beg===\n"
"@c tellsimpafter (foo (%pi + %e), 3*%pi);\n"
"@c tellsimpafter (foo (%pi * %e), 17*%e);\n"
"@c tellsimpafter (foo (%i ^ %e), -42*%i);\n"
"@c tellsimpafter (foo (9) + foo (13), quux (22));\n"
"@c tellsimpafter (foo (9) * foo (13), blurf (22));\n"
"@c tellsimpafter (foo (9) ^ foo (13), mumble (22));\n"
"@c rules;\n"
"@c foorule_name: first (%o1);\n"
"@c plusrule_name: first (%o4);\n"
"@c remrule (foo, foorule1);\n"
"@c remrule (\\"^\\", ?\^rule1);\n"
"@c rules;\n"
"@c ===end===\n"
"@example\n"
"(%i1) tellsimpafter (foo (%pi + %e), 3*%pi);\n"
"(%o1)                   [foorule1, false]\n"
"(%i2) tellsimpafter (foo (%pi * %e), 17*%e);\n"
"(%o2)              [foorule2, foorule1, false]\n"
"(%i3) tellsimpafter (foo (%i ^ %e), -42*%i);\n"
"(%o3)         [foorule3, foorule2, foorule1, false]\n"
"(%i4) tellsimpafter (foo (9) + foo (13), quux (22));\n"
"(%o4)                   [+rule1, simplus]\n"
"(%i5) tellsimpafter (foo (9) * foo (13), blurf (22));\n"
"(%o5)                  [*rule1, simptimes]\n"
"(%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));\n"
"(%o6)                  [^rule1, simpexpt]\n"
"(%i7) rules;\n"
"(%o7) [foorule1, foorule2, foorule3, +rule1, *rule1, ^rule1]\n"
"(%i8) foorule_name: first (%o1);\n"
"(%o8)                       foorule1\n"
"(%i9) plusrule_name: first (%o4);\n"
"(%o9)                        +rule1\n"
"(%i10) remrule (foo, foorule1);\n"
"(%o10)                         foo\n"
"(%i11) remrule (\\"^\\", ?\^rule1);\n"
"(%o11)                          ^\n"
"(%i12) rules;\n"
"(%o12)        [foorule2, foorule3, +rule1, *rule1]\n"
"@end example\n"
msgstr ""

#: Rules.texi:1217
msgid ""
"A worked example: anticommutative multiplication.\n"
msgstr ""

#: Rules.texi:1246
msgid ""
"@c ===beg===\n"
"@c gt (i, j) := integerp(j) and i < j;\n"
"@c matchdeclare (i, integerp, j, gt(i));\n"
"@c tellsimpafter (s[i]^^2, 1);\n"
"@c tellsimpafter (s[i] . s[j], -s[j] . s[i]);\n"
"@c s[1] . (s[1] + s[2]);\n"
"@c expand (%);\n"
"@c factor (expand (sum (s[i], i, 0, 9)^^5));\n"
"@c ===end===\n"
"@example\n"
"(%i1) gt (i, j) := integerp(j) and i < j;\n"
"(%o1)           gt(i, j) := integerp(j) and i < j\n"
"(%i2) matchdeclare (i, integerp, j, gt(i));\n"
"(%o2)                         done\n"
"(%i3) tellsimpafter (s[i]^^2, 1);\n"
"(%o3)                 [^^rule1, simpncexpt]\n"
"(%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);\n"
"(%o4)                   [.rule1, simpnct]\n"
"(%i5) s[1] . (s[1] + s[2]);\n"
"(%o5)                    s  . (s  + s )\n"
"                          1     2    1\n"
"(%i6) expand (%);\n"
"(%o6)                      1 - s  . s\n"
"                                2    1\n"
"(%i7) factor (expand (sum (s[i], i, 0, 9)^^5));\n"
"(%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )\n"
"            9    8    7    6    5    4    3    2    1    0\n"
"@end example\n"
msgstr ""

#: Rules.texi:1251
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: Rules.texi:1255
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{clear_rules}\n"
"@deffn {Function} clear_rules ()\n"
msgstr ""

#: Rules.texi:1258
msgid ""
"Executes @code{kill (rules)} and then resets the next rule number to 1\n"
"for addition @code{+}, multiplication @code{*}, and exponentiation @code{^}.\n"
msgstr ""

#: Rules.texi:1263
msgid ""
"@opencatbox\n"
"@category{Rules and patterns}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

