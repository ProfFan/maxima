# This file contains all translatable strings from a .texi file.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL>, YEAR.
#
#, fuzzy
msgid ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-05-06 22:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL>\n"
"Language-Team: LANGUAGE <LL.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
msgstr ""

#: stringproc.texi:8
msgid ""
"@menu\n"
"* Introduction to String Processing::\n"
"* Input and Output::\n"
"* Characters::\n"
"* String Processing::\n"
"* Octets and Utilities for Cryptography::\n"
"@end menu\n"
msgstr ""

#: stringproc.texi:13
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@c -----------------------------------------------------------------------------\n"
"@node Introduction to String Processing, Input and Output, stringproc-pkg, stringproc-pkg\n"
"@section Introduction to String Processing\n"
msgstr ""

#: stringproc.texi:18
msgid ""
"The package @code{stringproc} contains functions for processing strings \n"
"and characters including formatting, encoding and data streams. \n"
"This package is completed by some tools for cryptography, e.g. base64 and hash \n"
"functions.\n"
msgstr ""

#: stringproc.texi:21
msgid ""
"It can be directly loaded via @code{load(stringproc)} or automatically by \n"
"using one of its functions.\n"
msgstr ""

#: stringproc.texi:24
msgid ""
"For questions and bug reports please contact the author. The following \n"
"command prints his e-mail-address.\n"
msgstr ""

#: stringproc.texi:26
msgid ""
"@code{printf(true, \\"~@{~a~@}@@gmail.com\\", split(sdowncase(\\"Volker van Nek\\")))$}\n"
msgstr ""

#: stringproc.texi:32
msgid ""
"A string is constructed by typing e.g. @code{\\"Text\\"}. \n"
"When the option variable @code{stringdisp} is set to @code{false}, which is \n"
"the default, the double quotes won't be printed. \n"
"@ref{stringp} is a test, if an object is a string.\n"
msgstr ""

#: stringproc.texi:39
msgid ""
"@example\n"
"(%i1) str: \\"Text\\";\n"
"(%o1)                         Text\n"
"(%i2) stringp(str);\n"
"(%o2)                         true\n"
"@end example\n"
msgstr ""

#: stringproc.texi:42
msgid ""
"Characters are represented by a string of length 1. \n"
"@ref{charp} is the corresponding test.\n"
msgstr ""

#: stringproc.texi:49
msgid ""
"@example\n"
"(%i1) char: \\"e\\";\n"
"(%o1)                           e\n"
"(%i2) charp(char);\n"
"(%o2)                         true\n"
"@end example\n"
msgstr ""

#: stringproc.texi:52
msgid ""
"In Maxima position indices in strings are like in list 1-indexed \n"
"which results to the following consistency.\n"
msgstr ""

#: stringproc.texi:57
msgid ""
"@example\n"
"(%i1) is(charat(\\"Lisp\\",1) = charlist(\\"Lisp\\")[1]);\n"
"(%o1)                         true\n"
"@end example\n"
msgstr ""

#: stringproc.texi:60
msgid ""
"A string may contain Maxima expressions. \n"
"These can be parsed with @ref{parse_string}.\n"
msgstr ""

#: stringproc.texi:67
msgid ""
"@example\n"
"(%i1) map(parse_string, [\\"42\\" ,\\"sqrt(2)\\", \\"%pi\\"]);\n"
"(%o1)                   [42, sqrt(2), %pi]\n"
"(%i2) map('float, %);\n"
"(%o2)        [42.0, 1.414213562373095, 3.141592653589793]\n"
"@end example\n"
msgstr ""

#: stringproc.texi:73
msgid ""
"Strings can be processed as characters or in binary form as octets. \n"
"Functions for conversions are @ref{string_to_octets} and @ref{octets_to_string}.\n"
"Usable encodings depend on the platform, the application and the \n"
"underlying Lisp.\n"
"(The following shows Maxima in GNU/Linux, compiled with SBCL.)\n"
msgstr ""

#: stringproc.texi:81
msgid ""
"@example\n"
"(%i1) obase: 16.$\n"
"(%i2) string_to_octets(\\"$@pounds{}@euro{}\\", \\"cp1252\\");\n"
"(%o2)                     [24, 0A3, 80]\n"
"(%i3) string_to_octets(\\"$@pounds{}@euro{}\\", \\"utf-8\\");\n"
"(%o3)               [24, 0C2, 0A3, 0E2, 82, 0AC]\n"
"@end example\n"
msgstr ""

#: stringproc.texi:84
msgid ""
"Strings may be written to character streams or as octets to binary streams. \n"
"The following example demonstrates file in and output of characters.\n"
msgstr ""

#: stringproc.texi:88
msgid ""
"@ref{openw} returns an output stream to a file, \n"
"@ref{printf} writes formatted to that file and by e.g. \n"
"@ref{close} all characters contained in the stream are written to the file.\n"
msgstr ""

#: stringproc.texi:96
msgid ""
"@example\n"
"(%i1) s: openw(\\"file.txt\\");\n"
"(%o1)                #<output stream file.txt>\n"
"(%i2) printf(s, \\"~%~d ~f ~a ~a ~f ~e ~a~%\\", \n"
"42, 1.234, sqrt(2), %pi, 1.0e-2, 1.0e-2, 1.0b-2)$\n"
"(%i3) close(s)$\n"
"@end example\n"
msgstr ""

#: stringproc.texi:101
msgid ""
"@ref{openr} then returns an input stream from the previously used file and \n"
"@ref{readline} returns the line read as a string.\n"
"The string may be tokenized by e.g. @ref{split} or @ref{tokens} and \n"
"finally parsed by @ref{parse_string}.\n"
msgstr ""

#: stringproc.texi:111
msgid ""
"@example\n"
"(%i4) s: openr(\\"file.txt\\");\n"
"(%o4)                 #<input stream file.txt>\n"
"(%i5) readline(s);\n"
"(%o5)          42 1.234 sqrt(2) %pi 0.01 1.0E-2 1.0b-2\n"
"(%i6) map(parse_string, split(%));\n"
"(%o6)       [42, 1.234, sqrt(2), %pi, 0.01, 0.01, 1.0b-2]\n"
"(%i7) close(s)$\n"
"@end example\n"
msgstr ""

#: stringproc.texi:115
msgid ""
"@opencatbox\n"
"@category{Strings} @category{Share packages} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:121
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@c -----------------------------------------------------------------------------\n"
"@node Input and Output, Characters, Introduction to String Processing, stringproc-pkg\n"
"@section Input and Output\n"
msgstr ""

#: stringproc.texi:123
msgid ""
"Example: Formatted printing to a file.\n"
msgstr ""

#: stringproc.texi:142
msgid ""
"@example\n"
"(%i1) s: openw(\\"file.txt\\");\n"
"(%o1)                      #<output stream file.txt>\n"
"(%i2) control: \n"
"\\"~2tAn atom: ~20t~a~%~2tand a list: ~20t~@{~r ~@}~%~2t\\n"
"and an integer: ~20t~d~%\\"$\n"
"(%i3) printf( s,control, 'true,[1,2,3],42 )$\n"
"(%o3)                                false\n"
"(%i4) close(s);\n"
"(%o4)                                true\n"
"(%i5) s: openr(\\"file.txt\\");\n"
"(%o5)                      #<input stream file.txt>\n"
"(%i6) while stringp( tmp:readline(s) ) do print(tmp)$\n"
"  An atom:          true \n"
"  and a list:       one two three  \n"
"  and an integer:   42 \n"
"(%i7) close(s)$\n"
"@end example\n"
msgstr ""

#: stringproc.texi:146
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{close}\n"
"@deffn {Function} close (@var{stream}) \n"
msgstr ""

#: stringproc.texi:148
msgid ""
"Closes @var{stream} and returns @code{true} if @var{stream} had been open. \n"
msgstr ""

#: stringproc.texi:152
msgid ""
"@opencatbox\n"
"@category{File input} @category{File output} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:154
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:158
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{flength}\n"
"@deffn {Function} flength (@var{stream})\n"
msgstr ""

#: stringproc.texi:161
msgid ""
"@var{stream} has to be an open stream from or to a file. \n"
"@code{flength} then returns the number of bytes which are currently present in this file.\n"
msgstr ""

#: stringproc.texi:163
msgid ""
"Example: See @ref{writebyte} .\n"
msgstr ""

#: stringproc.texi:167
msgid ""
"@opencatbox\n"
"@category{File input} @category{File output} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:169
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:173
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{flush_output}\n"
"@deffn {Function} flush_output (@var{stream})\n"
msgstr ""

#: stringproc.texi:175
msgid ""
"Flushes @var{stream} where @var{stream} has to be an output stream to a file. \n"
msgstr ""

#: stringproc.texi:177
msgid ""
"Example: See @ref{writebyte} .\n"
msgstr ""

#: stringproc.texi:181
msgid ""
"@opencatbox\n"
"@category{File output} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:183
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:189
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{fposition}\n"
"@deffn {Function} fposition @\n"
"@fname{fposition} (@var{stream}) @\n"
"@fname{fposition} (@var{stream}, @var{pos})\n"
msgstr ""

#: stringproc.texi:194
msgid ""
"Returns the current position in @var{stream}, if @var{pos} is not used. \n"
"If @var{pos} is used, @code{fposition} sets the position in @var{stream}.\n"
"@var{stream} has to be a stream from or to a file and \n"
"@var{pos} has to be a positive number.\n"
msgstr ""

#: stringproc.texi:197
msgid ""
"Positions in data streams are like in strings or lists 1-indexed, \n"
"i.e. the first element in @var{stream} is in position 1.\n"
msgstr ""

#: stringproc.texi:201
msgid ""
"@opencatbox\n"
"@category{File input} @category{File output} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:203
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:209
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{freshline}\n"
"@deffn {Function} freshline @\n"
"@fname{freshline} ()  @\n"
"@fname{freshline} (@var{stream}) \n"
msgstr ""

#: stringproc.texi:214
msgid ""
"Writes a new line to the standard output stream \n"
"if the position is not at the beginning of a line und returns @code{true}.\n"
"Using the optional argument @var{stream} the new line is written to that stream. \n"
"There are some cases, where @code{freshline()} does not work as expected. \n"
msgstr ""

#: stringproc.texi:216
msgid ""
"See also @ref{newline}.\n"
msgstr ""

#: stringproc.texi:220
msgid ""
"@opencatbox\n"
"@category{File output} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:222
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:226
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{get_output_stream_string}\n"
"@deffn {Function} get_output_stream_string (@var{stream})\n"
msgstr ""

#: stringproc.texi:230
msgid ""
"Returns a string containing all the characters currently present in \n"
"@var{stream} which must be an open string-output stream. \n"
"The returned characters are removed from @var{stream}.\n"
msgstr ""

#: stringproc.texi:232
msgid ""
"Example: See @ref{make_string_output_stream} .\n"
msgstr ""

#: stringproc.texi:236
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:238
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:245
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{make_string_input_stream}\n"
"@deffn {Function} make_string_input_stream @\n"
"@fname{make_string_input_stream} (@var{string}) @\n"
"@fname{make_string_input_stream} (@var{string}, @var{start}) @\n"
"@fname{make_string_input_stream} (@var{string}, @var{start}, @var{end})\n"
msgstr ""

#: stringproc.texi:259
msgid ""
"Returns an input stream which contains parts of @var{string} and an end of file. \n"
"Without optional arguments the stream contains the entire string \n"
"and is positioned in front of the first character. \n"
"@var{start} and @var{end} define the substring contained in the stream. \n"
"The first character is available at position 1.\n"
" \n"
"@example\n"
"(%i1) istream : make_string_input_stream(\\"text\\", 1, 4);\n"
"(%o1)              #<string-input stream from \\"text\\">\n"
"(%i2) (while (c : readchar(istream)) # false do sprint(c), newline())$\n"
"t e x \n"
"(%i3) close(istream)$\n"
"@end example\n"
msgstr ""

#: stringproc.texi:263
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:265
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:269
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{make_string_output_stream}\n"
"@deffn {Function} make_string_output_stream ()\n"
msgstr ""

#: stringproc.texi:277
msgid ""
"Returns an output stream that accepts characters. Characters currently present \n"
"in this stream can be retrieved by @ref{get_output_stream_string}.\n"
" \n"
"@example\n"
"(%i1) ostream : make_string_output_stream();\n"
"(%o1)               #<string-output stream 09622ea0>\n"
"(%i2) printf(ostream, \\"foo\\")$\n"
msgstr ""

#: stringproc.texi:279
msgid ""
"(%i3) printf(ostream, \\"bar\\")$\n"
msgstr ""

#: stringproc.texi:283
msgid ""
"(%i4) string : get_output_stream_string(ostream);\n"
"(%o4)                            foobar\n"
"(%i5) printf(ostream, \\"baz\\")$\n"
msgstr ""

#: stringproc.texi:288
msgid ""
"(%i6) string : get_output_stream_string(ostream);\n"
"(%o6)                              baz\n"
"(%i7) close(ostream)$\n"
"@end example\n"
msgstr ""

#: stringproc.texi:292
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:294
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:300
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{newline}\n"
"@deffn {Function} newline @\n"
"@fname{newline} ()  @\n"
"@fname{newline} (@var{stream}) \n"
msgstr ""

#: stringproc.texi:304
msgid ""
"Writes a new line to the standard output stream. \n"
"Using the optional argument @var{stream} the new line is written to that stream. \n"
"There are some cases, where @code{newline()} does not work as expected. \n"
msgstr ""

#: stringproc.texi:306
msgid ""
"See @ref{sprint} for an example of using @code{newline()}.\n"
msgstr ""

#: stringproc.texi:310
msgid ""
"@opencatbox\n"
"@category{File output} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:312
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:316
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{opena}\n"
"@deffn {Function} opena (@var{file}) \n"
msgstr ""

#: stringproc.texi:319
msgid ""
"Returns a character output stream to @var{file}.\n"
"If an existing file is opened, @code{opena} appends elements at the end of @var{file}.\n"
msgstr ""

#: stringproc.texi:321
msgid ""
"For binary output see @ref{Functions and Variables for binary input and output, , opena_binary} .\n"
msgstr ""

#: stringproc.texi:325
msgid ""
"@opencatbox\n"
"@category{File output} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:327
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:333
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{openr}\n"
"@deffn {Function} openr @\n"
"@fname{openr} (@var{file}) @\n"
"@fname{openr} (@var{file}, @var{encoding}) \n"
msgstr ""

#: stringproc.texi:342
msgid ""
"Returns a character input stream to @var{file}.\n"
"@code{openr} assumes that @var{file} already exists.\n"
"If reading the file results in a lisp error about its encoding\n"
"passing the correct string as the argument @var{encoding} might help.\n"
"The available encodings and their names depend on the lisp being used.\n"
"For sbcl a list of suitable strings can be found at\n"
"@url{http://www.sbcl.org/manual/#External-Formats}.\n"
msgstr ""

#: stringproc.texi:345
msgid ""
"For binary input see @ref{Functions and Variables for binary input and output, , openr_binary} .\n"
"See also @mref{close} and @mrefdot{openw}\n"
msgstr ""

#: stringproc.texi:352
msgid ""
"@example\n"
"(%i1) istream : openr(\\"data.txt\\",\\"EUC-JP\\");\n"
"(%o1)     #<FD-STREAM for \\"file /home/gunter/data.txt\\" @{10099A3AE3@}>\n"
"(%i2) close(istream);\n"
"(%o2)                                true\n"
"@end example\n"
msgstr ""

#: stringproc.texi:357
msgid ""
"@opencatbox\n"
"@category{File input} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:359
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:363
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{openw}\n"
"@deffn {Function} openw (@var{file}) \n"
msgstr ""

#: stringproc.texi:367
msgid ""
"Returns a character output stream to @var{file}.\n"
"If @var{file} does not exist, it will be created.\n"
"If an existing file is opened, @code{openw} destructively modifies @var{file}.\n"
msgstr ""

#: stringproc.texi:369
msgid ""
"For binary output see @ref{Functions and Variables for binary input and output, , openw_binary} .\n"
msgstr ""

#: stringproc.texi:371
msgid ""
"See also @mref{close} and @mrefdot{openr}\n"
msgstr ""

#: stringproc.texi:375
msgid ""
"@opencatbox\n"
"@category{File output} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:377
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:383
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{printf}\n"
"@deffn {Function} printf @\n"
"@fname{printf} (@var{dest}, @var{string}) @\n"
"@fname{printf} (@var{dest}, @var{string}, @var{expr_1}, ..., @var{expr_n})\n"
msgstr ""

#: stringproc.texi:390
msgid ""
"Produces formatted output by outputting the characters of control-string \n"
"@var{string} and observing that a tilde introduces a directive.\n"
"The character after the tilde, possibly preceded by prefix parameters \n"
"and modifiers, specifies what kind of formatting is desired.\n"
"Most directives use one or more elements of the arguments \n"
"@var{expr_1}, ..., @var{expr_n} to create their output.\n"
msgstr ""

#: stringproc.texi:397
msgid ""
"If @var{dest} is a stream or @code{true}, then @code{printf} returns @code{false}.\n"
"Otherwise, @code{printf} returns a string containing the output.\n"
"By default the streams @var{stdin}, @var{stdout} and @var{stderr} are defined.\n"
"If maxima is running as a server (which is the normal case if maxima communicating\n"
"with a graphical user interface) @code{setup-client} will define @var{old_stdout} and\n"
"@var{old_stderr}, too.\n"
msgstr ""

#: stringproc.texi:401
msgid ""
"@code{printf} provides the Common Lisp function @code{format} in Maxima. \n"
"The following example illustrates the general relation between these two \n"
"functions.\n"
msgstr ""

#: stringproc.texi:410
msgid ""
"@example\n"
"(%i1) printf(true, \\"R~dD~d~%\\", 2, 2);\n"
"R2D2\n"
"(%o1)                                false\n"
"(%i2) :lisp (format t \\"R~dD~d~%\\" 2 2)\n"
"R2D2\n"
"NIL\n"
"@end example\n"
msgstr ""

#: stringproc.texi:416
msgid ""
"The following description is limited to a rough sketch of the possibilities of \n"
"@code{printf}.\n"
"The Lisp function @code{format} is described in detail in many reference books. \n"
"Of good help is e.g. the free available online-manual \n"
"\\"Common Lisp the Language\\" by Guy L. Steele. See chapter 22.3.3 there. \n"
msgstr ""

#: stringproc.texi:441
msgid ""
"@example\n"
"   ~%       new line\n"
"   ~&       fresh line\n"
"   ~t       tab\n"
"   ~$       monetary\n"
"   ~d       decimal integer\n"
"   ~b       binary integer\n"
"   ~o       octal integer\n"
"   ~x       hexadecimal integer\n"
"   ~br      base-b integer\n"
"   ~r       spell an integer\n"
"   ~p       plural\n"
"   ~f       floating point\n"
"   ~e       scientific notation\n"
"   ~g       ~f or ~e, depending upon magnitude\n"
"   ~h       bigfloat\n"
"   ~a       uses Maxima function string\n"
"   ~s       like ~a, but output enclosed in \\"double quotes\\"\n"
"   ~~       ~\n"
"   ~<       justification, ~> terminates\n"
"   ~(       case conversion, ~) terminates \n"
"   ~[       selection, ~] terminates \n"
"   ~@{       iteration, ~@} terminates\n"
"@end example\n"
msgstr ""

#: stringproc.texi:443
msgid ""
"The directive ~h for bigfloat is no Lisp-standard and is therefore illustrated below. \n"
msgstr ""

#: stringproc.texi:445
msgid ""
"Note that the directive ~* is not supported.\n"
msgstr ""

#: stringproc.texi:448
msgid ""
"If @var{dest} is a stream or @code{true}, then @code{printf} returns @code{false}.\n"
"Otherwise, @code{printf} returns a string containing the output.\n"
msgstr ""

#: stringproc.texi:464
msgid ""
"@example\n"
"(%i1) printf( false, \\"~a ~a ~4f ~a ~@@r\\", \n"
"              \\"String\\",sym,bound,sqrt(12),144), bound = 1.234;\n"
"(%o1)                 String sym 1.23 2*sqrt(3) CXLIV\n"
"(%i2) printf( false,\\"~@{~a ~@}\\",[\\"one\\",2,\\"THREE\\"] );\n"
"(%o2)                          one 2 THREE \n"
"(%i3) printf(true,\\"~@{~@{~9,1f ~@}~%~@}\\",mat ),\n"
"          mat = args(matrix([1.1,2,3.33],[4,5,6],[7,8.88,9]))$\n"
"      1.1       2.0       3.3 \n"
"      4.0       5.0       6.0 \n"
"      7.0       8.9       9.0 \n"
"(%i4) control: \\"~:(~r~) bird~p ~[is~;are~] singing.\\"$\n"
"(%i5) printf( false,control, n,n,if n=1 then 1 else 2 ), n=2;\n"
"(%o5)                    Two birds are singing.\n"
"@end example\n"
msgstr ""

#: stringproc.texi:466
msgid ""
"The directive ~h has been introduced to handle bigfloats. \n"
msgstr ""

#: stringproc.texi:477
msgid ""
"@example\n"
"~w,d,e,x,o,p@@H\n"
" w : width\n"
" d : decimal digits behind floating point\n"
" e : minimal exponent digits\n"
" x : preferred exponent\n"
" o : overflow character\n"
" p : padding character\n"
" @@ : display sign for positive numbers\n"
"@end example\n"
msgstr ""

#: stringproc.texi:503
msgid ""
"@example\n"
"(%i1) fpprec : 1000$\n"
"(%i2) printf(true, \\"|~h|~%\\", 2.b0^-64)$\n"
"|0.0000000000000000000542101086242752217003726400434970855712890625|\n"
"(%i3) fpprec : 26$\n"
"(%i4) printf(true, \\"|~h|~%\\", sqrt(2))$\n"
"|1.4142135623730950488016887|\n"
"(%i5) fpprec : 24$\n"
"(%i6) printf(true, \\"|~h|~%\\", sqrt(2))$\n"
"|1.41421356237309504880169|\n"
"(%i7) printf(true, \\"|~28h|~%\\", sqrt(2))$\n"
"|   1.41421356237309504880169|\n"
"(%i8) printf(true, \\"|~28,,,,,'*h|~%\\", sqrt(2))$\n"
"|***1.41421356237309504880169|\n"
"(%i9) printf(true, \\"|~,18h|~%\\", sqrt(2))$\n"
"|1.414213562373095049|\n"
"(%i10) printf(true, \\"|~,,,-3h|~%\\", sqrt(2))$\n"
"|1414.21356237309504880169b-3|\n"
"(%i11) printf(true, \\"|~,,2,-3h|~%\\", sqrt(2))$\n"
"|1414.21356237309504880169b-03|\n"
"(%i12) printf(true, \\"|~20h|~%\\", sqrt(2))$\n"
"|1.41421356237309504880169|\n"
"(%i13) printf(true, \\"|~20,,,,'+h|~%\\", sqrt(2))$\n"
"|++++++++++++++++++++|\n"
"@end example\n"
msgstr ""

#: stringproc.texi:507
msgid ""
"@opencatbox\n"
"@category{File output} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:509
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:513
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{readbyte}\n"
"@deffn {Function} readbyte (@var{stream})\n"
msgstr ""

#: stringproc.texi:516
msgid ""
"Removes and returns the first byte in @var{stream} which must be a binary input stream. \n"
"If the end of file is encountered @code{readbyte} returns @code{false}.\n"
msgstr ""

#: stringproc.texi:518
msgid ""
"Example: Read the first 16 bytes from a file encrypted with AES in OpenSSL. \n"
msgstr ""

#: stringproc.texi:521
msgid ""
"@example\n"
"(%i1) ibase: obase: 16.$\n"
msgstr ""

#: stringproc.texi:533
msgid ""
"(%i2) in: openr_binary(\\"msg.bin\\");\n"
"(%o2)                       #<input stream msg.bin>\n"
"(%i3) (L:[],  thru 16. do push(readbyte(in), L),  L:reverse(L));\n"
"(%o3) [53, 61, 6C, 74, 65, 64, 5F, 5F, 88, 56, 0DE, 8A, 74, 0FD, 0AD, 0F0]\n"
"(%i4) close(in);\n"
"(%o4)                                true\n"
"(%i5) map(ascii, rest(L,-8));\n"
"(%o5)                      [S, a, l, t, e, d, _, _]\n"
"(%i6) salt: octets_to_number(rest(L,8));\n"
"(%o6)                          8856de8a74fdadf0\n"
"@end example\n"
msgstr ""

#: stringproc.texi:537
msgid ""
"@opencatbox\n"
"@category{File input} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:539
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:543
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{readchar}\n"
"@deffn {Function} readchar (@var{stream})\n"
msgstr ""

#: stringproc.texi:546
msgid ""
"Removes and returns the first character in @var{stream}. \n"
"If the end of file is encountered @code{readchar} returns @code{false}.\n"
msgstr ""

#: stringproc.texi:548
msgid ""
"Example: See @ref{make_string_input_stream}.\n"
msgstr ""

#: stringproc.texi:552
msgid ""
"@opencatbox\n"
"@category{File input} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:554
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:558
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{readline}\n"
"@deffn {Function} readline (@var{stream}) \n"
msgstr ""

#: stringproc.texi:562
msgid ""
"Returns a string containing all characters starting at the current position \n"
"in @var{stream} up to the end of the line or @code{false} \n"
"if the end of the file is encountered.\n"
msgstr ""

#: stringproc.texi:566
msgid ""
"@opencatbox\n"
"@category{File input} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:568
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:572
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{sprint}\n"
"@deffn {Function} sprint (@var{expr_1}, @dots{}, @var{expr_n})\n"
msgstr ""

#: stringproc.texi:577
msgid ""
"Evaluates and displays its arguments one after the other `on a line' starting at\n"
"the leftmost position.  The expressions are printed with a space character right next \n"
"to the number, and it disregards line length.  \n"
"@code{newline()} might be used for line breaking.\n"
msgstr ""

#: stringproc.texi:580
msgid ""
"Example: Sequential printing with @code{sprint}. \n"
"Creating a new line with @code{newline()}.\n"
msgstr ""

#: stringproc.texi:591
msgid ""
"@example\n"
"(%i1) for n:0 thru 19 do sprint(fib(n))$\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181\n"
"(%i2) for n:0 thru 22 do ( \n"
"         sprint(fib(n)), \n"
"         if mod(n,10) = 9 then newline() )$\n"
"0 1 1 2 3 5 8 13 21 34 \n"
"55 89 144 233 377 610 987 1597 2584 4181 \n"
"6765 10946 17711 \n"
"@end example\n"
msgstr ""

#: stringproc.texi:596
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
"@end deffn\n"
msgstr ""

#: stringproc.texi:600
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{writebyte}\n"
"@deffn {Function} writebyte (@var{byte}, @var{stream})\n"
msgstr ""

#: stringproc.texi:603
msgid ""
"Writes @var{byte} to @var{stream} which must be a binary output stream. \n"
"@code{writebyte} returns @code{byte}.\n"
msgstr ""

#: stringproc.texi:608
msgid ""
"Example: Write some bytes to a binary file output stream. \n"
"In this example all bytes correspond to printable characters and are printed \n"
"by @code{printfile}. \n"
"The bytes remain in the stream until @code{flush_output} or @code{close} have been called.\n"
msgstr ""

#: stringproc.texi:611
msgid ""
"@example\n"
"(%i1) ibase: obase: 16.$\n"
msgstr ""

#: stringproc.texi:619
msgid ""
"(%i2) bytes: map(cint, charlist(\\"GNU/Linux\\"));\n"
"(%o2)                [47, 4E, 55, 2F, 4C, 69, 6E, 75, 78]\n"
"(%i3) out: openw_binary(\\"test.bin\\");\n"
"(%o3)                      #<output stream test.bin>\n"
"(%i4) for i thru 3 do writebyte(bytes[i], out);\n"
"(%o4)                                done\n"
"(%i5) printfile(\\"test.bin\\")$\n"
msgstr ""

#: stringproc.texi:635
msgid ""
"(%i6) flength(out);\n"
"(%o6)                                  0\n"
"(%i7) flush_output(out);\n"
"(%o7)                                true\n"
"(%i8) flength(out);\n"
"(%o8)                                  3\n"
"(%i9) printfile(\\"test.bin\\")$\n"
"GNU\n"
"(%i0A) for b in rest(bytes,3) do writebyte(b, out);\n"
"(%o0A)                               done\n"
"(%i0B) close(out);\n"
"(%o0B)                               true\n"
"(%i0C) printfile(\\"test.bin\\")$\n"
"GNU/Linux\n"
"@end example\n"
msgstr ""

#: stringproc.texi:639
msgid ""
"@opencatbox\n"
"@category{File output} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:641
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:646
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@c -----------------------------------------------------------------------------\n"
"@node Characters, String Processing, Input and Output, stringproc-pkg\n"
"@section Characters\n"
msgstr ""

#: stringproc.texi:648
msgid ""
"Characters are strings of length 1.\n"
msgstr ""

#: stringproc.texi:652
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{adjust_external_format}\n"
"@deffn {Function} adjust_external_format () \n"
msgstr ""

#: stringproc.texi:659
msgid ""
"Prints information about the current external format of the Lisp reader \n"
"and in case the external format encoding differs from the encoding of the \n"
"application which runs Maxima @code{adjust_external_format} tries to adjust \n"
"the encoding or prints some help or instruction.\n"
"@code{adjust_external_format} returns @code{true} when the external format has \n"
"been changed and @code{false} otherwise.\n"
msgstr ""

#: stringproc.texi:663
msgid ""
"Functions like @ref{cint}, @ref{unicode}, @ref{octets_to_string} \n"
"and @ref{string_to_octets} need UTF-8 as the external format of the \n"
"Lisp reader to work properly over the full range of Unicode characters. \n"
msgstr ""

#: stringproc.texi:667
msgid ""
"Examples (Maxima on Windows, March 2016): \n"
"Using @code{adjust_external_format} when the default external format \n"
"is not equal to the encoding provided by the application.\n"
msgstr ""

#: stringproc.texi:669
msgid ""
"1. Command line Maxima\n"
msgstr ""

#: stringproc.texi:673
msgid ""
"In case a terminal session is preferred it is recommended to use Maxima compiled \n"
"with SBCL. Here Unicode support is provided by default and calls to \n"
"@code{adjust_external_format} are unnecessary. \n"
msgstr ""

#: stringproc.texi:677
msgid ""
"If Maxima is compiled with CLISP or GCL it is recommended to change \n"
"the terminal encoding from CP850 to CP1252. \n"
"@code{adjust_external_format} prints some help. \n"
msgstr ""

#: stringproc.texi:682
msgid ""
"CCL reads UTF-8 while the terminal input is CP850 by default. \n"
"CP1252 is not supported by CCL. @code{adjust_external_format} \n"
"prints instructions for changing the terminal encoding and external format \n"
"both to iso-8859-1.\n"
msgstr ""

#: stringproc.texi:684
msgid ""
"2. wxMaxima\n"
msgstr ""

#: stringproc.texi:687
msgid ""
"In wxMaxima SBCL reads CP1252 by default but the input from the application \n"
"is UTF-8 encoded. Adjustment is needed. \n"
msgstr ""

#: stringproc.texi:690
msgid ""
"Calling @code{adjust_external_format} and restarting Maxima \n"
"permanently changes the default external format to UTF-8.\n"
msgstr ""

#: stringproc.texi:700
msgid ""
"@example\n"
"(%i1)adjust_external_format();\n"
"The line\n"
"(setf sb-impl::*default-external-format* :utf-8)\n"
"has been appended to the init file\n"
"C:/Users/Username/.sbclrc\n"
"Please restart Maxima to set the external format to UTF-8.\n"
"(%i1) false\n"
"@end example\n"
msgstr ""

#: stringproc.texi:702
msgid ""
"Restarting Maxima.\n"
msgstr ""

#: stringproc.texi:709
msgid ""
"@example\n"
"(%i1) adjust_external_format();\n"
"The external format is currently UTF-8\n"
"and has not been changed.\n"
"(%i1) false\n"
"@end example\n"
msgstr ""

#: stringproc.texi:713
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:715
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:721
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{alphacharp}\n"
"@deffn {Function} alphacharp (@var{char})  \n"
"  \n"
"Returns @code{true} if @var{char} is an alphabetic character. \n"
msgstr ""

#: stringproc.texi:728
msgid ""
"To identify a non-US-ASCII character as an alphabetic character \n"
"the underlying Lisp must provide full Unicode support. \n"
"E.g. a German umlaut is detected as an alphabetic character with SBCL in GNU/Linux \n"
"but not with GCL. \n"
"(In Windows Maxima, when compiled with SBCL, must be set to UTF-8. \n"
"See @ref{adjust_external_format} for more.) \n"
msgstr ""

#: stringproc.texi:730
msgid ""
"Example: Examination of non-US-ASCII characters.\n"
msgstr ""

#: stringproc.texi:733
msgid ""
"The underlying Lisp (SBCL, GNU/Linux) is able to convert the typed character \n"
"into a Lisp character and to examine.\n"
msgstr ""

#: stringproc.texi:738
msgid ""
"@example\n"
"(%i1) alphacharp(\\"@\\"u\\");\n"
"(%o1)                          true\n"
"@end example\n"
msgstr ""

#: stringproc.texi:740
msgid ""
"In GCL this is not possible. An error break occurs.\n"
msgstr ""

#: stringproc.texi:745
msgid ""
"@example\n"
"(%i1) alphacharp(\\"u\\");\n"
"(%o1)                          true\n"
"(%i2) alphacharp(\\"@\\"u\\");\n"
msgstr ""

#: stringproc.texi:749
msgid ""
"package stringproc: @\\"u cannot be converted into a Lisp character.\n"
" -- an error.\n"
"@end example\n"
msgstr ""

#: stringproc.texi:753
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:755
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:759
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{alphanumericp}\n"
"@deffn {Function} alphanumericp (@var{char}) \n"
msgstr ""

#: stringproc.texi:762
msgid ""
"Returns @code{true} if @var{char} is an alphabetic character or a digit \n"
"(only corresponding US-ASCII characters are regarded as digits). \n"
msgstr ""

#: stringproc.texi:764
msgid ""
"Note: See remarks on @ref{alphacharp}. \n"
msgstr ""

#: stringproc.texi:768
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:770
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:774
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{ascii}\n"
"@deffn {Function} ascii (@var{int}) \n"
msgstr ""

#: stringproc.texi:777
msgid ""
"Returns the US-ASCII character corresponding to the integer @var{int}\n"
"which has to be less than @code{128}.\n"
msgstr ""

#: stringproc.texi:779
msgid ""
"See @ref{unicode} for converting code points larger than @code{127}.\n"
msgstr ""

#: stringproc.texi:781
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:790
msgid ""
"@example\n"
"(%i1) for n from 0 thru 127 do ( \n"
"        ch: ascii(n), \n"
"        if alphacharp(ch) then sprint(ch),\n"
"        if n = 96 then newline() )$\n"
"A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \n"
"a b c d e f g h i j k l m n o p q r s t u v w x y z\n"
"@end example\n"
msgstr ""

#: stringproc.texi:794
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:796
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:802
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{cequal}\n"
"@deffn {Function} cequal (@var{char_1}, @var{char_2}) \n"
"         \n"
"Returns @code{true} if @var{char_1} and @var{char_2} are the same character. \n"
msgstr ""

#: stringproc.texi:806
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:808
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:816
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{cequalignore}\n"
"@deffn {Function} cequalignore (@var{char_1}, @var{char_2}) \n"
"  \n"
"Like @code{cequal} but ignores case which is only possible for non-US-ASCII \n"
"characters when the underlying Lisp is able to recognize a character as an \n"
"alphabetic character. See remarks on @ref{alphacharp}. \n"
msgstr ""

#: stringproc.texi:820
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:822
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:829
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{cgreaterp}\n"
"@deffn {Function} cgreaterp (@var{char_1}, @var{char_2}) \n"
"  \n"
"Returns @code{true} if the code point of @var{char_1} is greater than the \n"
"code point of @var{char_2}. \n"
msgstr ""

#: stringproc.texi:833
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:835
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:839
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{cgreaterpignore}\n"
"@deffn {Function} cgreaterpignore (@var{char_1}, @var{char_2}) \n"
msgstr ""

#: stringproc.texi:843
msgid ""
"Like @code{cgreaterp} but ignores case which is only possible for non-US-ASCII \n"
"characters when the underlying Lisp is able to recognize a character as an \n"
"alphabetic character. See remarks on @ref{alphacharp}. \n"
msgstr ""

#: stringproc.texi:847
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:849
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:853
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{charp}\n"
"@deffn {Function} charp (@var{obj}) \n"
msgstr ""

#: stringproc.texi:856
msgid ""
"Returns @code{true} if @var{obj} is a Maxima-character.\n"
"See introduction for example.\n"
msgstr ""

#: stringproc.texi:860
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:862
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:866
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{cint}\n"
"@deffn {Function} cint (@var{char}) \n"
msgstr ""

#: stringproc.texi:869
msgid ""
"Returns the Unicode code point of @var{char} which must be a \n"
"Maxima character, i.e. a string of length @code{1}.\n"
msgstr ""

#: stringproc.texi:872
msgid ""
"Examples: The hexadecimal code point of some characters \n"
"(Maxima with SBCL on GNU/Linux). \n"
msgstr ""

#: stringproc.texi:878
msgid ""
"@example\n"
"(%i1) obase: 16.$\n"
"(%i2) map(cint, [\\"$\\",\\"@pounds{}\\",\\"@euro{}\\"]);\n"
"(%o2)                           [24, 0A3, 20AC]\n"
"@end example\n"
msgstr ""

#: stringproc.texi:882
msgid ""
"Warning: It is not possible to enter characters corresponding to code points \n"
"larger than 16 bit in wxMaxima with SBCL on Windows when the external format \n"
"has not been set to UTF-8. See @ref{adjust_external_format}.\n"
msgstr ""

#: stringproc.texi:888
msgid ""
"@c Command @U not supported by texinfo 5.\n"
"@c @example\n"
"@c (%i3) cint(\\"@U{1d538}\\");\n"
"@c (%o3)                                1D538\n"
"@c @end example\n"
msgstr ""

#: stringproc.texi:893
msgid ""
"CMUCL doesn't process these characters as one character. \n"
"@code{cint} then returns @code{false}. \n"
"@c Converting to UTF-8-octets and finally to Unicode serves as a workaround.\n"
"Converting a character to a code point via UTF-8-octets may serve as a workaround: \n"
msgstr ""

#: stringproc.texi:895
msgid ""
"@code{utf8_to_unicode(string_to_octets(character));}\n"
msgstr ""

#: stringproc.texi:901
msgid ""
"@c Command @U not supported by texinfo 5.\n"
"@c @example\n"
"@c (%i4) utf8_to_unicode(string_to_octets(\\"@U{1d538}\\"));\n"
"@c (%o4)                                1D538\n"
"@c @end example\n"
msgstr ""

#: stringproc.texi:903
msgid ""
"See @ref{utf8_to_unicode}, @ref{string_to_octets}.\n"
msgstr ""

#: stringproc.texi:907
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:909
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:913
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{clessp}\n"
"@deffn {Function} clessp (@var{char_1}, @var{char_2})\n"
msgstr ""

#: stringproc.texi:916
msgid ""
"Returns @code{true} if the code point of @var{char_1} is less than the \n"
"code point of @var{char_2}. \n"
msgstr ""

#: stringproc.texi:920
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:922
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:926
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{clesspignore}\n"
"@deffn {Function} clesspignore (@var{char_1}, @var{char_2})\n"
msgstr ""

#: stringproc.texi:930
msgid ""
"Like @code{clessp} but ignores case which is only possible for non-US-ASCII \n"
"characters when the underlying Lisp is able to recognize a character as an \n"
"alphabetic character. See remarks on @ref{alphacharp}. \n"
msgstr ""

#: stringproc.texi:934
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:936
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:940
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{constituent}\n"
"@deffn {Function} constituent (@var{char}) \n"
msgstr ""

#: stringproc.texi:945
msgid ""
"Returns @code{true} if @var{char} is a graphic character but not a space character.\n"
"A graphic character is a character one can see, plus the space character.\n"
"(@code{constituent} is defined by Paul Graham. \n"
"See Paul Graham, ANSI Common Lisp, 1996, page 67.)\n"
msgstr ""

#: stringproc.texi:953
msgid ""
"@example\n"
"(%i1) for n from 0 thru 255 do ( \n"
"tmp: ascii(n), if constituent(tmp) then sprint(tmp) )$\n"
"! \\" #  %  ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @@ A B\n"
"C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c\n"
"d e f g h i j k l m n o p q r s t u v w x y z @{ | @} ~\n"
"@end example\n"
msgstr ""

#: stringproc.texi:957
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:959
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:970
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@c @deffn {Function} cunlisp (@var{lisp_char}) \n"
"@c Converts a Lisp-character into a Maxima-character.\n"
"@c (You won't need it.)\n"
"@c \n"
"@c @opencatbox\n"
"@c @category{Package stringproc}\n"
"@c @closecatbox\n"
"@c \n"
"@c @end deffn\n"
msgstr ""

#: stringproc.texi:977
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{digitcharp}\n"
"@deffn {Function} digitcharp (@var{char}) \n"
"  \n"
"Returns @code{true} if @var{char} is a digit where only the corresponding \n"
"US-ASCII-character is regarded as a digit.\n"
msgstr ""

#: stringproc.texi:981
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:983
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:994
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@c @deffn {Function} lcharp (@var{obj}) \n"
"@c Returns @code{true} if @var{obj} is a Lisp-character.\n"
"@c (You won't need it.)\n"
"@c \n"
"@c @opencatbox\n"
"@c @category{Predicate functions} @category{Package stringproc}\n"
"@c @closecatbox\n"
"@c \n"
"@c @end deffn\n"
msgstr ""

#: stringproc.texi:1000
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{lowercasep}\n"
"@deffn {Function} lowercasep (@var{char}) \n"
"   \n"
"Returns @code{true} if @var{char} is a lowercase character. \n"
msgstr ""

#: stringproc.texi:1002
msgid ""
"Note: See remarks on @ref{alphacharp}.\n"
msgstr ""

#: stringproc.texi:1006
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1008
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1012
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{newline_variable}\n"
"@defvr {Variable} newline \n"
msgstr ""

#: stringproc.texi:1014
msgid ""
"The newline character (ASCII-character 10). \n"
msgstr ""

#: stringproc.texi:1018
msgid ""
"@opencatbox\n"
"@category{Global variables} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1020
msgid ""
"@end defvr\n"
msgstr ""

#: stringproc.texi:1024
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{space_variable}\n"
"@defvr {Variable} space   \n"
msgstr ""

#: stringproc.texi:1026
msgid ""
"The space character.\n"
msgstr ""

#: stringproc.texi:1030
msgid ""
"@opencatbox\n"
"@category{Global variables} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1032
msgid ""
"@end defvr\n"
msgstr ""

#: stringproc.texi:1036
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{tab_variable}\n"
"@defvr {Variable} tab     \n"
msgstr ""

#: stringproc.texi:1038
msgid ""
"The tab character.\n"
msgstr ""

#: stringproc.texi:1042
msgid ""
"@opencatbox\n"
"@category{Global variables} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1044
msgid ""
"@end defvr\n"
msgstr ""

#: stringproc.texi:1048
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{unicode}\n"
"@deffn {Function} unicode (@var{arg}) \n"
msgstr ""

#: stringproc.texi:1051
msgid ""
"Returns the character defined by @var{arg} which might be a Unicode code point \n"
"or a name string if the underlying Lisp provides full Unicode support. \n"
msgstr ""

#: stringproc.texi:1054
msgid ""
"Example: Characters defined by hexadecimal code points\n"
"(Maxima with SBCL on GNU/Linux). \n"
msgstr ""

#: stringproc.texi:1060
msgid ""
"@example\n"
"(%i1) ibase: 16.$\n"
"(%i2) map(unicode, [24, 0A3, 20AC]);\n"
"(%o2)                            [$, @pounds{}, @euro{}]\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1064
msgid ""
"Warning: In wxMaxima with SBCL on Windows it is not possible to convert \n"
"code points larger than 16 bit to characters when the external format \n"
"has not been set to UTF-8. See @ref{adjust_external_format} for more information.\n"
msgstr ""

#: stringproc.texi:1070
msgid ""
"@c Command @U not supported by texinfo 5.\n"
"@c @example\n"
"@c (%i3) unicode(1D538);\n"
"@c (%o3)                                  @U{1d538}\n"
"@c @end example\n"
msgstr ""

#: stringproc.texi:1075
msgid ""
"CMUCL doesn't process code points larger than 16 bit. \n"
"In these cases @code{unicode} returns @code{false}. \n"
"@c Converting characters to UTF-8 octets and finally to Unicode serves as a workaround.\n"
"Converting a code point to a character via UTF-8 octets may serve as a workaround: \n"
msgstr ""

#: stringproc.texi:1077
msgid ""
"@code{octets_to_string(unicode_to_utf8(code_point));}\n"
msgstr ""

#: stringproc.texi:1083
msgid ""
"@c Command @U not supported by texinfo 5.\n"
"@c @example\n"
"@c (%i4) octets_to_string(unicode_to_utf8(1D538));\n"
"@c (%o4)                                  @U{1d538}\n"
"@c @end example\n"
msgstr ""

#: stringproc.texi:1085
msgid ""
"See @ref{octets_to_string}, @ref{unicode_to_utf8}.\n"
msgstr ""

#: stringproc.texi:1091
msgid ""
"In case the underlying Lisp provides full Unicode support the character might be \n"
"specified by its name. The following is possible in ECL, CLISP and SBCL, \n"
"where in SBCL on Windows the external format has to be set to UTF-8.\n"
"@code{unicode(name)} is supported by CMUCL too but again limited to 16 bit \n"
"characters. \n"
msgstr ""

#: stringproc.texi:1096
msgid ""
"The string argument to @code{unicode} is basically the same string returned by \n"
"@code{printf} using the \\"~@@c\\" specifier. \n"
"But as shown below the prefix \\"#\\\" must be omitted. \n"
"Underlines might be replaced by spaces and uppercase letters by lowercase ones.\n"
msgstr ""

#: stringproc.texi:1099
msgid ""
"Example (continued): Characters defined by names \n"
"(Maxima with SBCL on GNU/Linux). \n"
msgstr ""

#: stringproc.texi:1108
msgid ""
"@example\n"
"(%i3) printf(false, \\"~@@c\\", unicode(0DF));\n"
"(%o3)                    #\LATIN_SMALL_LETTER_SHARP_S\n"
"(%i4) unicode(\\"LATIN_SMALL_LETTER_SHARP_S\\");\n"
"(%o4)                                  @ss{}\n"
"(%i5) unicode(\\"Latin small letter sharp s\\");\n"
"(%o5)                                  @ss{}\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1112
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1114
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1118
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{unicode_to_utf8}\n"
"@deffn {Function} unicode_to_utf8 (@var{code_point}) \n"
msgstr ""

#: stringproc.texi:1120
msgid ""
"Returns a list containing the UTF-8 code corresponding to the Unicode @var{code_point}.\n"
msgstr ""

#: stringproc.texi:1122
msgid ""
"Examples: Converting Unicode code points to UTF-8 and vice versa. \n"
msgstr ""

#: stringproc.texi:1132
msgid ""
"@example\n"
"(%i1) ibase: obase: 16.$\n"
"(%i2) map(cint, [\\"$\\",\\"@pounds{}\\",\\"@euro{}\\"]);\n"
"(%o2)                           [24, 0A3, 20AC]\n"
"(%i3) map(unicode_to_utf8, %);\n"
"(%o3)                 [[24], [0C2, 0A3], [0E2, 82, 0AC]]\n"
"(%i4) map(utf8_to_unicode, %);\n"
"(%o4)                           [24, 0A3, 20AC]\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1136
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1138
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1144
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{uppercasep}\n"
"@deffn {Function} uppercasep (@var{char})  \n"
"  \n"
"Returns @code{true} if @var{char} is an uppercase character. \n"
msgstr ""

#: stringproc.texi:1146
msgid ""
"Note: See remarks on @ref{alphacharp}.\n"
msgstr ""

#: stringproc.texi:1150
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1152
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1156
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{us_ascii_only}\n"
"@defvr {Variable} us_ascii_only\n"
msgstr ""

#: stringproc.texi:1160
msgid ""
"This option variable affects Maxima when the character encoding \n"
"provided by the application which runs Maxima is UTF-8 but the \n"
"external format of the Lisp reader is not equal to UTF-8. \n"
msgstr ""

#: stringproc.texi:1166
msgid ""
"On GNU/Linux this is true when Maxima is built with GCL \n"
"and on Windows in wxMaxima with GCL- and SBCL-builds. \n"
"With SBCL it is recommended to change the external format to UTF-8. \n"
"Setting @code{us_ascii_only} is unnecessary then. \n"
"See @ref{adjust_external_format} for details. \n"
msgstr ""

#: stringproc.texi:1169
msgid ""
"@code{us_ascii_only} is @code{false} by default. \n"
"Maxima itself then (i.e. in the above described situation) parses the UTF-8 encoding.\n"
msgstr ""

#: stringproc.texi:1173
msgid ""
"When @code{us_ascii_only} is set to @code{true} it is assumed that all strings \n"
"used as arguments to string processing functions do not contain Non-US-ASCII characters. \n"
"Given that promise, Maxima avoids parsing UTF-8 and strings can be processed more efficiently.\n"
msgstr ""

#: stringproc.texi:1177
msgid ""
"@opencatbox\n"
"@category{Global variables} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1179
msgid ""
"@end defvr\n"
msgstr ""

#: stringproc.texi:1183
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{utf8_to_unicode}\n"
"@deffn {Function} utf8_to_unicode (@var{list}) \n"
msgstr ""

#: stringproc.texi:1186
msgid ""
"Returns a Unicode code point corresponding to the @var{list} which must contain \n"
"the UTF-8 encoding of a single character.\n"
msgstr ""

#: stringproc.texi:1188
msgid ""
"Examples: See @ref{unicode_to_utf8}.\n"
msgstr ""

#: stringproc.texi:1192
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1194
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1199
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@c -----------------------------------------------------------------------------\n"
"@node String Processing, Octets and Utilities for Cryptography, Characters, stringproc-pkg\n"
"@section String Processing\n"
msgstr ""

#: stringproc.texi:1202
msgid ""
"Position indices in strings are 1-indexed like in Maxima lists. \n"
"See example in @ref{charat}.\n"
msgstr ""

#: stringproc.texi:1206
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{charat}\n"
"@deffn {Function} charat (@var{string}, @var{n}) \n"
msgstr ""

#: stringproc.texi:1209
msgid ""
"Returns the @var{n}-th character of @var{string}.\n"
"The first character in @var{string} is returned with @var{n} = 1. \n"
msgstr ""

#: stringproc.texi:1216
msgid ""
"@example\n"
"(%i1) charat(\\"Lisp\\",1);\n"
"(%o1)                           L\n"
"(%i2) charlist(\\"Lisp\\")[1];\n"
"(%o2)                           L\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1220
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1222
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1226
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{charlist}\n"
"@deffn {Function} charlist (@var{string}) \n"
msgstr ""

#: stringproc.texi:1228
msgid ""
"Returns the list of all characters in @var{string}. \n"
msgstr ""

#: stringproc.texi:1233
msgid ""
"@example\n"
"(%i1) charlist(\\"Lisp\\");\n"
"(%o1)                     [L, i, s, p]\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1237
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1239
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1243
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{eval_string}\n"
"@deffn {Function} eval_string (@var{str})\n"
msgstr ""

#: stringproc.texi:1247
msgid ""
"Parse the string @var{str} as a Maxima expression and evaluate it.\n"
"The string @var{str} may or may not have a terminator (dollar sign @code{$} or semicolon @code{;}).\n"
"Only the first expression is parsed and evaluated, if there is more than one.\n"
msgstr ""

#: stringproc.texi:1249
msgid ""
"Complain if @var{str} is not a string.\n"
msgstr ""

#: stringproc.texi:1251
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:1258
msgid ""
"@example\n"
"(%i1) eval_string (\\"foo: 42; bar: foo^2 + baz\\");\n"
"(%o1)                       42\n"
"(%i2) eval_string (\\"(foo: 42, bar: foo^2 + baz)\\");\n"
"(%o2)                   baz + 1764\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1260
msgid ""
"See also @ref{parse_string}.\n"
msgstr ""

#: stringproc.texi:1264
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1266
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1270
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{parse_string}\n"
"@deffn {Function} parse_string (@var{str})\n"
msgstr ""

#: stringproc.texi:1274
msgid ""
"Parse the string @var{str} as a Maxima expression (do not evaluate it).\n"
"The string @var{str} may or may not have a terminator (dollar sign @code{$} or semicolon @code{;}).\n"
"Only the first expression is parsed, if there is more than one.\n"
msgstr ""

#: stringproc.texi:1276
msgid ""
"Complain if @var{str} is not a string.\n"
msgstr ""

#: stringproc.texi:1278
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:1286
msgid ""
"@example\n"
"(%i1) parse_string (\\"foo: 42; bar: foo^2 + baz\\");\n"
"(%o1)                    foo : 42\n"
"(%i2) parse_string (\\"(foo: 42, bar: foo^2 + baz)\\");\n"
"                                   2\n"
"(%o2)          (foo : 42, bar : foo  + baz)\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1288
msgid ""
"See also @ref{eval_string}.\n"
msgstr ""

#: stringproc.texi:1292
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1294
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1298
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{scopy}\n"
"@deffn {Function} scopy (@var{string}) \n"
msgstr ""

#: stringproc.texi:1300
msgid ""
"Returns a copy of @var{string} as a new string. \n"
msgstr ""

#: stringproc.texi:1304
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1306
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1313
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{sdowncase}\n"
"@deffn {Function} sdowncase @\n"
"@fname{sdowncase} (@var{string}) @\n"
"@fname{sdowncase} (@var{string}, @var{start})  @\n"
"@fname{sdowncase} (@var{string}, @var{start}, @var{end})\n"
msgstr ""

#: stringproc.texi:1315
msgid ""
"Like @ref{supcase} but uppercase characters are converted to lowercase. \n"
msgstr ""

#: stringproc.texi:1319
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1321
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1325
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{sequal}\n"
"@deffn {Function} sequal (@var{string_1}, @var{string_2}) \n"
msgstr ""

#: stringproc.texi:1328
msgid ""
"Returns @code{true} if @var{string_1} and @var{string_2} contain the same \n"
"sequence of characters. \n"
msgstr ""

#: stringproc.texi:1332
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1334
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1338
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{sequalignore}\n"
"@deffn {Function} sequalignore (@var{string_1}, @var{string_2})\n"
msgstr ""

#: stringproc.texi:1342
msgid ""
"Like @code{sequal} but ignores case which is only possible for non-US-ASCII \n"
"characters when the underlying Lisp is able to recognize a character as an \n"
"alphabetic character. See remarks on @ref{alphacharp}. \n"
msgstr ""

#: stringproc.texi:1346
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1348
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1352
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{sexplode}\n"
"@deffn {Function} sexplode (@var{string})\n"
msgstr ""

#: stringproc.texi:1354
msgid ""
"@code{sexplode} is an alias for function @code{charlist}.\n"
msgstr ""

#: stringproc.texi:1358
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1360
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1366
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{simplode}\n"
"@deffn {Function} simplode @\n"
"@fname{simplode} (@var{list})   @\n"
"@fname{simplode} (@var{list}, @var{delim})  \n"
msgstr ""

#: stringproc.texi:1370
msgid ""
"@code{simplode} takes a list of expressions and concatenates them into a string.\n"
"If no delimiter @var{delim} is specified, @code{simplode} uses no delimiter.\n"
"@var{delim} can be any string.\n"
msgstr ""

#: stringproc.texi:1372
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:1381
msgid ""
"@example\n"
"(%i1) simplode([\\"xx[\\",3,\\"]:\\",expand((x+y)^3)]);\n"
"(%o1)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3\n"
"(%i2) simplode( sexplode(\\"stars\\"),\\" * \\" );\n"
"(%o2)                   s * t * a * r * s\n"
"(%i3) simplode( [\\"One\\",\\"more\\",\\"coffee.\\"],\\" \\" );\n"
"(%o3)                   One more coffee.\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1385
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1387
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1394
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{sinsert}\n"
"@deffn {Function} sinsert (@var{seq}, @var{string}, @var{pos})  \n"
"Returns a string that is a concatenation of @code{substring(@var{string}, 1, @var{pos}-1)},\n"
"the string @var{seq} and @code{substring (@var{string}, @var{pos})}.\n"
"Note that the first character in @var{string} is in position 1.\n"
msgstr ""

#: stringproc.texi:1396
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:1404
msgid ""
"@example\n"
"(%i1) s: \\"A submarine.\\"$\n"
"(%i2) concat( substring(s,1,3),\\"yellow \\",substring(s,3) );\n"
"(%o2)                  A yellow submarine.\n"
"(%i3) sinsert(\\"hollow \\",s,3);\n"
"(%o3)                  A hollow submarine.\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1408
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1410
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1417
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{sinvertcase}\n"
"@deffn {Function} sinvertcase @\n"
"@fname{sinvertcase} (@var{string}) @\n"
"@fname{sinvertcase} (@var{string}, @var{start}) @\n"
"@fname{sinvertcase} (@var{string}, @var{start}, @var{end})\n"
msgstr ""

#: stringproc.texi:1421
msgid ""
"Returns @var{string} except that each character from position @var{start} to @var{end} is inverted.\n"
"If @var{end} is not given,\n"
"all characters from @var{start} to the end of @var{string} are replaced.\n"
msgstr ""

#: stringproc.texi:1423
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:1428
msgid ""
"@example\n"
"(%i1) sinvertcase(\\"sInvertCase\\");\n"
"(%o1)                      SiNVERTcASE\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1432
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1434
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1438
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{slength}\n"
"@deffn {Function} slength (@var{string}) \n"
msgstr ""

#: stringproc.texi:1440
msgid ""
"Returns the number of characters in @var{string}. \n"
msgstr ""

#: stringproc.texi:1444
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1446
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1450
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{smake}\n"
"@deffn {Function} smake (@var{num}, @var{char}) \n"
msgstr ""

#: stringproc.texi:1452
msgid ""
"Returns a new string with a number of @var{num} characters @var{char}. \n"
msgstr ""

#: stringproc.texi:1454
msgid ""
"Example:\n"
msgstr ""

#: stringproc.texi:1459
msgid ""
"@example\n"
"(%i1) smake(3,\\"w\\");\n"
"(%o1)                          www\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1463
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1465
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1471
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{smismatch}\n"
"@deffn {Function} smismatch @\n"
"@fname{smismatch} (@var{string_1}, @var{string_2}) @\n"
"@fname{smismatch} (@var{string_1}, @var{string_2}, @var{test})\n"
msgstr ""

#: stringproc.texi:1475
msgid ""
"Returns the position of the first character of @var{string_1} at which @var{string_1} and @var{string_2} differ or @code{false}.\n"
"Default test function for matching is @code{sequal}.\n"
"If @code{smismatch} should ignore case, use @code{sequalignore} as test.\n"
msgstr ""

#: stringproc.texi:1477
msgid ""
"Example:\n"
msgstr ""

#: stringproc.texi:1482
msgid ""
"@example\n"
"(%i1) smismatch(\\"seven\\",\\"seventh\\");\n"
"(%o1)                           6\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1486
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1488
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1495
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{split}\n"
"@deffn {Function} split @\n"
"@fname{split} (@var{string}) @\n"
"@fname{split} (@var{string}, @var{delim}) @\n"
"@fname{split} (@var{string}, @var{delim}, @var{multiple})\n"
msgstr ""

#: stringproc.texi:1504
msgid ""
"Returns the list of all tokens in @var{string}.\n"
"Each token is an unparsed string.\n"
"@code{split} uses @var{delim} as delimiter.\n"
"If @var{delim} is not given, the space character is the default delimiter.\n"
"@var{multiple} is a boolean variable with @code{true} by default.\n"
"Multiple delimiters are read as one.\n"
"This is useful if tabs are saved as multiple space characters.\n"
"If @var{multiple} is set to @code{false}, each delimiter is noted.\n"
msgstr ""

#: stringproc.texi:1506
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:1513
msgid ""
"@example\n"
"(%i1) split(\\"1.2   2.3   3.4   4.5\\");\n"
"(%o1)                 [1.2, 2.3, 3.4, 4.5]\n"
"(%i2) split(\\"first;;third;fourth\\",\\";\\",false);\n"
"(%o2)               [first, , third, fourth]\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1517
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1519
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1526
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{sposition}\n"
"@deffn {Function} sposition (@var{char}, @var{string}) \n"
"Returns the position of the first character in @var{string} which matches @var{char}.\n"
"The first character in @var{string} is in position 1.\n"
"For matching characters ignoring case see @ref{ssearch}.\n"
msgstr ""

#: stringproc.texi:1530
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1532
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1540
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{sremove}\n"
"@deffn {Function} sremove @\n"
"@fname{sremove} (@var{seq}, @var{string}) @\n"
"@fname{sremove} (@var{seq}, @var{string}, @var{test}) @\n"
"@fname{sremove} (@var{seq}, @var{string}, @var{test}, @var{start}) @\n"
"@fname{sremove} (@var{seq}, @var{string}, @var{test}, @var{start}, @var{end})\n"
msgstr ""

#: stringproc.texi:1546
msgid ""
"Returns a string like @var{string} but without all substrings matching @var{seq}.\n"
"Default test function for matching is @code{sequal}.\n"
"If @code{sremove} should ignore case while searching for @var{seq}, use @code{sequalignore} as test.\n"
"Use @var{start} and @var{end} to limit searching.\n"
"Note that the first character in @var{string} is in position 1.\n"
msgstr ""

#: stringproc.texi:1548
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:1555
msgid ""
"@example\n"
"(%i1) sremove(\\"n't\\",\\"I don't like coffee.\\");\n"
"(%o1)                   I do like coffee.\n"
"(%i2) sremove (\\"DO \\",%,'sequalignore);\n"
"(%o2)                    I like coffee.\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1559
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1561
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1569
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{sremovefirst}\n"
"@deffn {Function} sremovefirst @\n"
"@fname{sremovefirst} (@var{seq}, @var{string}) @\n"
"@fname{sremovefirst} (@var{seq}, @var{string}, @var{test}) @\n"
"@fname{sremovefirst} (@var{seq}, @var{string}, @var{test}, @var{start}) @\n"
"@fname{sremovefirst} (@var{seq}, @var{string}, @var{test}, @var{start}, @var{end})\n"
msgstr ""

#: stringproc.texi:1571
msgid ""
"Like @code{sremove} except that only the first substring that matches @var{seq} is removed.\n"
msgstr ""

#: stringproc.texi:1575
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1577
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1581
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{sreverse}\n"
"@deffn {Function} sreverse (@var{string}) \n"
msgstr ""

#: stringproc.texi:1583
msgid ""
"Returns a string with all the characters of @var{string} in reverse order. \n"
msgstr ""

#: stringproc.texi:1587
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1589
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1597
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{ssearch}\n"
"@deffn {Function} ssearch @\n"
"@fname{ssearch} (@var{seq}, @var{string}) @\n"
"@fname{ssearch} (@var{seq}, @var{string}, @var{test}) @\n"
"@fname{ssearch} (@var{seq}, @var{string}, @var{test}, @var{start}) @\n"
"@fname{ssearch} (@var{seq}, @var{string}, @var{test}, @var{start}, @var{end})\n"
msgstr ""

#: stringproc.texi:1603
msgid ""
"Returns the position of the first substring of @var{string} that matches the string @var{seq}.\n"
"Default test function for matching is @code{sequal}.\n"
"If @code{ssearch} should ignore case, use @code{sequalignore} as test.\n"
"Use @var{start} and @var{end} to limit searching.\n"
"Note that the first character in @var{string} is in position 1.\n"
msgstr ""

#: stringproc.texi:1605
msgid ""
"Example:\n"
msgstr ""

#: stringproc.texi:1610
msgid ""
"@example\n"
"(%i1) ssearch(\\"~s\\",\\"~@{~S ~@}~%\\",'sequalignore);\n"
"(%o1)                                  4\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1614
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1616
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1622
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{ssort}\n"
"@deffn {Function} ssort @\n"
"@fname{ssort} (@var{string}) @\n"
"@fname{ssort} (@var{string}, @var{test})\n"
msgstr ""

#: stringproc.texi:1626
msgid ""
"Returns a string that contains all characters from @var{string} in an order such there are no two successive characters @var{c} and @var{d} such that @code{test (@var{c}, @var{d})} is @code{false} and @code{test (@var{d}, @var{c})} is @code{true}.\n"
"Default test function for sorting is @var{clessp}.\n"
"The set of test functions is @code{@{clessp, clesspignore, cgreaterp, cgreaterpignore, cequal, cequalignore@}}.\n"
msgstr ""

#: stringproc.texi:1628
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:1635
msgid ""
"@example\n"
"(%i1) ssort(\\"I don't like Mondays.\\");\n"
"(%o1)                    '.IMaddeiklnnoosty\n"
"(%i2) ssort(\\"I don't like Mondays.\\",'cgreaterpignore);\n"
"(%o2)                 ytsoonnMlkIiedda.'   \n"
"@end example\n"
msgstr ""

#: stringproc.texi:1639
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1641
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1649
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{ssubst}\n"
"@deffn {Function} ssubst @\n"
"@fname{ssubst} (@var{new}, @var{old}, @var{string}) @\n"
"@fname{ssubst} (@var{new}, @var{old}, @var{string}, @var{test}) @\n"
"@fname{ssubst} (@var{new}, @var{old}, @var{string}, @var{test}, @var{start}) @\n"
"@fname{ssubst} (@var{new}, @var{old}, @var{string}, @var{test}, @var{start}, @var{end})\n"
msgstr ""

#: stringproc.texi:1656
msgid ""
"Returns a string like @var{string} except that all substrings matching @var{old} are replaced by @var{new}.\n"
"@var{old} and @var{new} need not to be of the same length.\n"
"Default test function for matching is @code{sequal}.\n"
"If @code{ssubst} should ignore case while searching for old, use @code{sequalignore} as test.\n"
"Use @var{start} and @var{end} to limit searching.\n"
"Note that the first character in @var{string} is in position 1.\n"
msgstr ""

#: stringproc.texi:1658
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:1665
msgid ""
"@example\n"
"(%i1) ssubst(\\"like\\",\\"hate\\",\\"I hate Thai food. I hate green tea.\\");\n"
"(%o1)          I like Thai food. I like green tea.\n"
"(%i2) ssubst(\\"Indian\\",\\"thai\\",%,'sequalignore,8,12);\n"
"(%o2)         I like Indian food. I like green tea.\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1669
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1671
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1679
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{ssubstfirst}\n"
"@deffn {Function} ssubstfirst @\n"
"@fname{ssubstfirst} (@var{new}, @var{old}, @var{string}) @\n"
"@fname{ssubstfirst} (@var{new}, @var{old}, @var{string}, @var{test}) @\n"
"@fname{ssubstfirst} (@var{new}, @var{old}, @var{string}, @var{test}, @var{start}) @\n"
"@fname{ssubstfirst} (@var{new}, @var{old}, @var{string}, @var{test}, @var{start}, @var{end})\n"
msgstr ""

#: stringproc.texi:1681
msgid ""
"Like @code{subst} except that only the first substring that matches @var{old} is replaced.\n"
msgstr ""

#: stringproc.texi:1685
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1687
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1691
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{strim}\n"
"@deffn {Function} strim (@var{seq},@var{string}) \n"
msgstr ""

#: stringproc.texi:1694
msgid ""
"Returns a string like @var{string},\n"
"but with all characters that appear in @var{seq} removed from both ends. \n"
msgstr ""

#: stringproc.texi:1696
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:1704
msgid ""
"@example\n"
"(%i1) \\"/* comment */\\"$\n"
"(%i2) strim(\\" /*\\",%);\n"
"(%o2)                        comment\n"
"(%i3) slength(%);\n"
"(%o3)                           7\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1708
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1710
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1714
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{striml}\n"
"@deffn {Function} striml (@var{seq}, @var{string}) \n"
msgstr ""

#: stringproc.texi:1716
msgid ""
"Like @code{strim} except that only the left end of @var{string} is trimmed. \n"
msgstr ""

#: stringproc.texi:1720
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1722
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1726
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{strimr}\n"
"@deffn {Function} strimr (@var{seq}, @var{string}) \n"
msgstr ""

#: stringproc.texi:1728
msgid ""
"Like @code{strim} except that only the right end of @var{string} is trimmed.\n"
msgstr ""

#: stringproc.texi:1732
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1734
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1738
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{stringp}\n"
"@deffn {Function} stringp (@var{obj}) \n"
msgstr ""

#: stringproc.texi:1741
msgid ""
"Returns @code{true} if @var{obj} is a string.\n"
"See introduction for example.\n"
msgstr ""

#: stringproc.texi:1745
msgid ""
"@opencatbox\n"
"@category{Predicate functions} @category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1747
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1753
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{substring}\n"
"@deffn {Function} substring @\n"
"@fname{substring} (@var{string}, @var{start}) @\n"
"@fname{substring} (@var{string}, @var{start}, @var{end})\n"
msgstr ""

#: stringproc.texi:1758
msgid ""
"Returns the substring of @var{string} beginning at position @var{start} and ending at position @var{end}.\n"
"The character at position @var{end} is not included.\n"
"If @var{end} is not given, the substring contains the rest of the string.\n"
"Note that the first character in @var{string} is in position 1.\n"
msgstr ""

#: stringproc.texi:1760
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:1767
msgid ""
"@example\n"
"(%i1) substring(\\"substring\\",4);\n"
"(%o1)                        string\n"
"(%i2) substring(%,4,6);\n"
"(%o2)                          in\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1771
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1773
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1780
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{supcase}\n"
"@deffn {Function} supcase @\n"
"@fname{supcase} (@var{string}) @\n"
"@fname{supcase} (@var{string}, @var{start}) @\n"
"@fname{supcase} (@var{string}, @var{start}, @var{end})\n"
msgstr ""

#: stringproc.texi:1784
msgid ""
"Returns @var{string} except that lowercase characters from position @var{start} to @var{end} are replaced by the corresponding uppercase ones.\n"
"If @var{end} is not given,\n"
"all lowercase characters from @var{start} to the end of @var{string} are replaced.\n"
msgstr ""

#: stringproc.texi:1786
msgid ""
"Example:\n"
msgstr ""

#: stringproc.texi:1791
msgid ""
"@example\n"
"(%i1) supcase(\\"english\\",1,2);\n"
"(%o1)                        English\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1795
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1797
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1803
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{tokens}\n"
"@deffn {Function} tokens @\n"
"@fname{tokens} (@var{string}) @\n"
"@fname{tokens} (@var{string}, @var{test})\n"
msgstr ""

#: stringproc.texi:1809
msgid ""
"Returns a list of tokens, which have been extracted from @var{string}.\n"
"The tokens are substrings whose characters satisfy a certain test function.\n"
"If test is not given, @var{constituent} is used as the default test.\n"
"@code{@{constituent, alphacharp, digitcharp, lowercasep, uppercasep, charp, characterp, alphanumericp@}} is the set of test functions. \n"
"(The Lisp-version of @code{tokens} is written by Paul Graham. ANSI Common Lisp, 1996, page 67.)\n"
msgstr ""

#: stringproc.texi:1811
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:1820
msgid ""
"@example\n"
"(%i1) tokens(\\"24 October 2005\\");\n"
"(%o1)                  [24, October, 2005]\n"
"(%i2) tokens(\\"05-10-24\\",'digitcharp);\n"
"(%o2)                     [05, 10, 24]\n"
"(%i3) map(parse_string,%);\n"
"(%o3)                      [5, 10, 24]\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1824
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1826
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1831
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@c -----------------------------------------------------------------------------\n"
"@node Octets and Utilities for Cryptography,  , String Processing, stringproc-pkg\n"
"@section Octets and Utilities for Cryptography\n"
msgstr ""

#: stringproc.texi:1835
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{base64}\n"
"@deffn {Function} base64 (@var{arg})\n"
msgstr ""

#: stringproc.texi:1838
msgid ""
"Returns the base64-representation of @var{arg} as a string. \n"
"The argument @var{arg} may be a string, a non-negative integer or a list of octets.\n"
msgstr ""

#: stringproc.texi:1840
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:1855
msgid ""
"@example\n"
"(%i1) base64: base64(\\"foo bar baz\\");\n"
"(%o1)                          Zm9vIGJhciBiYXo=\n"
"(%i2) string: base64_decode(base64);\n"
"(%o2)                            foo bar baz\n"
"(%i3) obase: 16.$\n"
"(%i4) integer: base64_decode(base64, 'number);\n"
"(%o4)                       666f6f206261722062617a\n"
"(%i5) octets: base64_decode(base64, 'list);\n"
"(%o5)            [66, 6F, 6F, 20, 62, 61, 72, 20, 62, 61, 7A]\n"
"(%i6) ibase: 16.$\n"
"(%i7) base64(octets);\n"
"(%o7)                          Zm9vIGJhciBiYXo=\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1859
msgid ""
"Note that if @var{arg} contains umlauts (resp. octets larger than 127) \n"
"the resulting base64-string is platform dependend. \n"
"However the decoded string will be equal to the original.\n"
msgstr ""

#: stringproc.texi:1863
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1865
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1871
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{base64_decode}\n"
"@deffn {Function} base64_decode @\n"
"@fname{base64_decode} (@var{base64-string}) @\n"
"@fname{base64_decode} (@var{base64-string}, @var{return-type})\n"
msgstr ""

#: stringproc.texi:1873
msgid ""
"By default @code{base64_decode} decodes the @var{base64-string} back to the original string. \n"
msgstr ""

#: stringproc.texi:1877
msgid ""
"The optional argument @var{return-type} allows @code{base64_decode} to \n"
"alternatively return the corresponding number or list of octets.\n"
"@var{return-type} may be @code{string}, @code{number} or @code{list}.\n"
msgstr ""

#: stringproc.texi:1879
msgid ""
"Example: See @ref{base64}.\n"
msgstr ""

#: stringproc.texi:1883
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1885
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1891
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{crc24sum}\n"
"@deffn {Function} crc24sum @\n"
"@fname{crc24sum} (@var{octets}) @\n"
"@fname{crc24sum} (@var{octets}, @var{return-type})\n"
msgstr ""

#: stringproc.texi:1894
msgid ""
"By default @code{crc24sum} returns the @code{CRC24} checksum of an octet-list \n"
"as a string.\n"
msgstr ""

#: stringproc.texi:1898
msgid ""
"The optional argument @var{return-type} allows @code{crc24sum} to \n"
"alternatively return the corresponding number or list of octets.\n"
"@var{return-type} may be @code{string}, @code{number} or @code{list}.\n"
msgstr ""

#: stringproc.texi:1900
msgid ""
"Example:\n"
msgstr ""

#: stringproc.texi:1904
msgid ""
"@example\n"
"-----BEGIN PGP SIGNATURE-----\n"
"Version: GnuPG v2.0.22 (GNU/Linux)\n"
msgstr ""

#: stringproc.texi:1914
msgid ""
"iQEcBAEBAgAGBQJVdCTzAAoJEG/1Mgf2DWAqCSYH/AhVFwhu1D89C3/QFcgVvZTM\n"
"wnOYzBUURJAL/cT+IngkLEpp3hEbREcugWp+Tm6aw3R4CdJ7G3FLxExBH/5KnDHi\n"
"rBQu+I7+3ySK2hpryQ6Wx5J9uZSa4YmfsNteR8up0zGkaulJeWkS4pjiRM+auWVe\n"
"vajlKZCIK52P080DG7Q2dpshh4fgTeNwqCuCiBhQ73t8g1IaLdhDN6EzJVjGIzam\n"
"/spqT/sTo6sw8yDOJjvU+Qvn6/mSMjC/YxjhRMaQt9EMrR1AZ4ukBF5uG1S7mXOH\n"
"WdiwkSPZ3gnIBhM9SuC076gLWZUNs6NqTeE3UzMjDAFhH3jYk1T7mysCvdtIkms=\n"
"=WmeC\n"
"-----END PGP SIGNATURE-----\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1930
msgid ""
"@example\n"
"(%i1) ibase : obase : 16.$\n"
"(%i2) sig64 : sconcat(\n"
" \\"iQEcBAEBAgAGBQJVdCTzAAoJEG/1Mgf2DWAqCSYH/AhVFwhu1D89C3/QFcgVvZTM\\",\n"
" \\"wnOYzBUURJAL/cT+IngkLEpp3hEbREcugWp+Tm6aw3R4CdJ7G3FLxExBH/5KnDHi\\",\n"
" \\"rBQu+I7+3ySK2hpryQ6Wx5J9uZSa4YmfsNteR8up0zGkaulJeWkS4pjiRM+auWVe\\",\n"
" \\"vajlKZCIK52P080DG7Q2dpshh4fgTeNwqCuCiBhQ73t8g1IaLdhDN6EzJVjGIzam\\",\n"
" \\"/spqT/sTo6sw8yDOJjvU+Qvn6/mSMjC/YxjhRMaQt9EMrR1AZ4ukBF5uG1S7mXOH\\",\n"
" \\"WdiwkSPZ3gnIBhM9SuC076gLWZUNs6NqTeE3UzMjDAFhH3jYk1T7mysCvdtIkms=\\" )$\n"
"(%i3) octets: base64_decode(sig64, 'list)$\n"
"(%i4) crc24: crc24sum(octets, 'list);\n"
"(%o4)                          [5A, 67, 82]\n"
"(%i5) base64(crc24);\n"
"(%o5)                              WmeC\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1934
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1936
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1942
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{md5sum}\n"
"@deffn {Function} md5sum @\n"
"@fname{md5sum} (@var{arg}) @\n"
"@fname{md5sum} (@var{arg}, @var{return-type})\n"
msgstr ""

#: stringproc.texi:1945
msgid ""
"Returns the @code{MD5} checksum of a string, a non-negative integer or \n"
"a list of octets. The default return value is a string containing 32 hex characters.\n"
msgstr ""

#: stringproc.texi:1949
msgid ""
"The optional argument @var{return-type} allows @code{md5sum} to alternatively \n"
"return the corresponding number or list of octets.\n"
"@var{return-type} may be @code{string}, @code{number} or @code{list}.\n"
msgstr ""

#: stringproc.texi:1951
msgid ""
"Examples:\n"
msgstr ""

#: stringproc.texi:1964
msgid ""
"@example\n"
"(%i1) ibase: obase: 16.$\n"
"(%i2) msg: \\"foo bar baz\\"$\n"
"(%i3) string: md5sum(msg);\n"
"(%o3)                  ab07acbb1e496801937adfa772424bf7\n"
"(%i4) integer: md5sum(msg, 'number);\n"
"(%o4)                 0ab07acbb1e496801937adfa772424bf7\n"
"(%i5) octets: md5sum(msg, 'list);\n"
"(%o5)        [0AB,7,0AC,0BB,1E,49,68,1,93,7A,0DF,0A7,72,42,4B,0F7]\n"
"(%i6) sdowncase( printf(false, \\"~@{~2,'0x~^:~@}\\", octets) );\n"
"(%o6)           ab:07:ac:bb:1e:49:68:01:93:7a:df:a7:72:42:4b:f7\n"
"@end example\n"
msgstr ""

#: stringproc.texi:1967
msgid ""
"Note that in case @var{arg} contains German umlauts or other non-ASCII \n"
"characters (resp. octets larger than 127) the @code{MD5} checksum is platform dependend.\n"
msgstr ""

#: stringproc.texi:1971
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:1973
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:1979
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{mgf1_sha1}\n"
"@deffn {Function} mgf1_sha1 @\n"
"@fname{mgf1_sha1} (@var{seed}, @var{len}) @\n"
"@fname{mgf1_sha1} (@var{seed}, @var{len}, @var{return-type})\n"
msgstr ""

#: stringproc.texi:1982
msgid ""
"Returns a pseudo random number of variable length. \n"
"By default the returned value is a number with a length of @var{len} octets.\n"
msgstr ""

#: stringproc.texi:1986
msgid ""
"The optional argument @var{return-type} allows @code{mgf1_sha1} to alternatively \n"
"return the corresponding list of @var{len} octets.\n"
"@var{return-type} may be @code{number} or @code{list}.\n"
msgstr ""

#: stringproc.texi:1991
msgid ""
"The computation of the returned value is described in @code{RFC 3447}, \n"
"appendix @code{B.2.1 MGF1}. \n"
"@code{SHA1} ist used as hash function, i.e. the randomness of the computed number \n"
"relies on the randomness of @code{SHA1} hashes.\n"
msgstr ""

#: stringproc.texi:1993
msgid ""
"Example:\n"
msgstr ""

#: stringproc.texi:2001
msgid ""
"@example\n"
"(%i1) ibase: obase: 16.$\n"
"(%i2) number: mgf1_sha1(4711., 8);\n"
"(%o2)                        0e0252e5a2a42fea1\n"
"(%i3) octets: mgf1_sha1(4711., 8, 'list);\n"
"(%o3)                  [0E0,25,2E,5A,2A,42,0FE,0A1]\n"
"@end example\n"
msgstr ""

#: stringproc.texi:2005
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:2007
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:2011
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{number_to_octets}\n"
"@deffn {Function} number_to_octets (@var{number})\n"
msgstr ""

#: stringproc.texi:2014
msgid ""
"Returns an octet-representation of @var{number} as a list of octets.\n"
"The @var{number} must be a non-negative integer.\n"
msgstr ""

#: stringproc.texi:2016
msgid ""
"Example:\n"
msgstr ""

#: stringproc.texi:2025
msgid ""
"@example\n"
"(%i1) ibase : obase : 16.$\n"
"(%i2) octets: [0ca,0fe,0ba,0be]$\n"
"(%i3) number: octets_to_number(octets);\n"
"(%o3)                            0cafebabe\n"
"(%i4) number_to_octets(number);\n"
"(%o4)                      [0CA, 0FE, 0BA, 0BE]\n"
"@end example\n"
msgstr ""

#: stringproc.texi:2029
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:2031
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:2035
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{octets_to_number}\n"
"@deffn {Function} octets_to_number (@var{octets})\n"
msgstr ""

#: stringproc.texi:2037
msgid ""
"Returns a number by concatenating the octets in the list of @var{octets}.\n"
msgstr ""

#: stringproc.texi:2039
msgid ""
"Example: See @ref{number_to_octets}.\n"
msgstr ""

#: stringproc.texi:2043
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:2045
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:2049
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{octets_to_oid}\n"
"@deffn {Function} octets_to_oid (@var{octets})\n"
msgstr ""

#: stringproc.texi:2051
msgid ""
"Computes an object identifier (OID) from the list of @var{octets}.\n"
msgstr ""

#: stringproc.texi:2053
msgid ""
"Example: RSA encryption OID\n"
msgstr ""

#: stringproc.texi:2061
msgid ""
"@example\n"
"(%i1) ibase : obase : 16.$\n"
"(%i2) oid: octets_to_oid([2A,86,48,86,0F7,0D,1,1,1]);\n"
"(%o2)                      1.2.840.113549.1.1.1\n"
"(%i3) oid_to_octets(oid);\n"
"(%o3)               [2A, 86, 48, 86, 0F7, 0D, 1, 1, 1]\n"
"@end example\n"
msgstr ""

#: stringproc.texi:2065
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:2067
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:2073
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{octets_to_string}\n"
"@deffn {Function} octets_to_string @\n"
"@fname{octets_to_string} (@var{octets})  @\n"
"@fname{octets_to_string} (@var{octets}, @var{encoding}) \n"
msgstr ""

#: stringproc.texi:2077
msgid ""
"Decodes the list of @var{octets} into a string according to current system defaults. \n"
"When decoding octets corresponding to Non-US-ASCII characters \n"
"the result depends on the platform, application and underlying Lisp.\n"
msgstr ""

#: stringproc.texi:2081
msgid ""
"Example: Using system defaults \n"
"(Maxima compiled with GCL, which uses no format definition and \n"
"simply passes through the UTF-8-octets encoded by the GNU/Linux terminal).\n"
msgstr ""

#: stringproc.texi:2097
msgid ""
"@example\n"
"(%i1) octets: string_to_octets(\\"abc\\");\n"
"(%o1)                            [61, 62, 63]\n"
"(%i2) octets_to_string(octets);\n"
"(%o2)                                 abc\n"
"(%i3) ibase: obase: 16.$\n"
"(%i4) unicode(20AC);\n"
"(%o4)                                  @euro{}\n"
"(%i5) octets: string_to_octets(%);\n"
"(%o5)                           [0E2, 82, 0AC]\n"
"(%i6) octets_to_string(octets);\n"
"(%o6)                                  @euro{}\n"
"(%i7) utf8_to_unicode(octets);\n"
"(%o7)                                20AC\n"
"@end example\n"
msgstr ""

#: stringproc.texi:2101
msgid ""
"In case the external format of the Lisp reader is equal to UTF-8 the optional \n"
"argument @var{encoding} allows to set the encoding for the octet to string conversion. \n"
"If necessary see @ref{adjust_external_format} for changing the external format. \n"
msgstr ""

#: stringproc.texi:2109
msgid ""
"Some names of supported encodings (see corresponding Lisp manual for more): @*\n"
"CCL, CLISP, SBCL: @code{utf-8, ucs-2be, ucs-4be, iso-8859-1, cp1252, cp850} @*\n"
"CMUCL: @code{utf-8, utf-16-be, utf-32-be, iso8859-1, cp1252} @*\n"
"ECL: @code{utf-8, ucs-2be, ucs-4be, iso-8859-1, windows-cp1252, dos-cp850} \n"
"   \n"
"Example (continued): Using the optional encoding argument \n"
"(Maxima compiled with SBCL, GNU/Linux terminal).\n"
msgstr ""

#: stringproc.texi:2114
msgid ""
"@example\n"
"(%i8) string_to_octets(\\"@euro{}\\", \\"ucs-2be\\");\n"
"(%o8)                              [20, 0AC]\n"
"@end example\n"
msgstr ""

#: stringproc.texi:2118
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:2120
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:2124
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{oid_to_octets}\n"
"@deffn {Function} oid_to_octets (@var{oid-string})\n"
msgstr ""

#: stringproc.texi:2126
msgid ""
"Convertes an object identifier (OID) to a list of @var{octets}.\n"
msgstr ""

#: stringproc.texi:2128
msgid ""
"Example: See @ref{octets_to_oid}.\n"
msgstr ""

#: stringproc.texi:2132
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:2134
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:2140
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{sha1sum}\n"
"@deffn {Function} sha1sum @\n"
"@fname{sha1sum} (@var{arg}) @\n"
"@fname{sha1sum} (@var{arg}, @var{return-type})\n"
msgstr ""

#: stringproc.texi:2143
msgid ""
"Returns the @code{SHA1} fingerprint of a string, a non-negative integer or \n"
"a list of octets. The default return value is a string containing 40 hex characters.\n"
msgstr ""

#: stringproc.texi:2147
msgid ""
"The optional argument @var{return-type} allows @code{sha1sum} to alternatively \n"
"return the corresponding number or list of octets.\n"
"@var{return-type} may be @code{string}, @code{number} or @code{list}.\n"
msgstr ""

#: stringproc.texi:2149
msgid ""
"Example:\n"
msgstr ""

#: stringproc.texi:2162
msgid ""
"@example\n"
"(%i1) ibase: obase: 16.$\n"
"(%i2) msg: \\"foo bar baz\\"$\n"
"(%i3) string: sha1sum(msg);\n"
"(%o3)              c7567e8b39e2428e38bf9c9226ac68de4c67dc39\n"
"(%i4) integer: sha1sum(msg, 'number);\n"
"(%o4)             0c7567e8b39e2428e38bf9c9226ac68de4c67dc39\n"
"(%i5) octets: sha1sum(msg, 'list);\n"
"(%o5)  [0C7,56,7E,8B,39,0E2,42,8E,38,0BF,9C,92,26,0AC,68,0DE,4C,67,0DC,39]\n"
"(%i6) sdowncase( printf(false, \\"~@{~2,'0x~^:~@}\\", octets) );\n"
"(%o6)     c7:56:7e:8b:39:e2:42:8e:38:bf:9c:92:26:ac:68:de:4c:67:dc:39\n"
"@end example\n"
msgstr ""

#: stringproc.texi:2165
msgid ""
"Note that in case @var{arg} contains German umlauts or other non-ASCII \n"
"characters (resp. octets larger than 127) the @code{SHA1} fingerprint is platform dependend.\n"
msgstr ""

#: stringproc.texi:2169
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:2171
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:2177
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{sha256sum}\n"
"@deffn {Function} sha256sum @\n"
"@fname{sha256sum} (@var{arg}) @\n"
"@fname{sha256sum} (@var{arg}, @var{return-type})\n"
msgstr ""

#: stringproc.texi:2180
msgid ""
"Returns the @code{SHA256} fingerprint of a string, a non-negative integer or \n"
"a list of octets. The default return value is a string containing 64 hex characters.\n"
msgstr ""

#: stringproc.texi:2183
msgid ""
"The optional argument @var{return-type} allows @code{sha256sum} to alternatively \n"
"return the corresponding number or list of octets (see @ref{sha1sum}).\n"
msgstr ""

#: stringproc.texi:2185
msgid ""
"Example:\n"
msgstr ""

#: stringproc.texi:2190
msgid ""
"@example\n"
"(%i1) string: sha256sum(\\"foo bar baz\\");\n"
"(%o1)  dbd318c1c462aee872f41109a4dfd3048871a03dedd0fe0e757ced57dad6f2d7\n"
"@end example\n"
msgstr ""

#: stringproc.texi:2193
msgid ""
"Note that in case @var{arg} contains German umlauts or other non-ASCII \n"
"characters (resp. octets larger than 127) the @code{SHA256} fingerprint is platform dependend.\n"
msgstr ""

#: stringproc.texi:2197
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:2199
msgid ""
"@end deffn\n"
msgstr ""

#: stringproc.texi:2205
msgid ""
"@c -----------------------------------------------------------------------------\n"
"@anchor{string_to_octets}\n"
"@deffn {Function} string_to_octets @\n"
"@fname{string_to_octets} (@var{string})  @\n"
"@fname{string_to_octets} (@var{string}, @var{encoding}) \n"
msgstr ""

#: stringproc.texi:2209
msgid ""
"Encodes a @var{string} into a list of octets according to current system defaults. \n"
"When encoding strings containing Non-US-ASCII characters \n"
"the result depends on the platform, application and underlying Lisp.\n"
msgstr ""

#: stringproc.texi:2213
msgid ""
"In case the external format of the Lisp reader is equal to UTF-8 the optional \n"
"argument @var{encoding} allows to set the encoding for the string to octet conversion. \n"
"If necessary see @ref{adjust_external_format} for changing the external format. \n"
msgstr ""

#: stringproc.texi:2215
msgid ""
"See @ref{octets_to_string} for examples and some more information.\n"
msgstr ""

#: stringproc.texi:2219
msgid ""
"@opencatbox\n"
"@category{Package stringproc}\n"
"@closecatbox\n"
msgstr ""

#: stringproc.texi:2221
msgid ""
"@end deffn\n"
msgstr ""

